?~
demo()
demo(graphics)
fjdslakjflkjsld
demo(graphics)
demo()
demo(glm.vr)
hlep(gl)
help(gl)
help(glm)
help(symnum)
ls()
load("nwInf.out.tall_predall.RData")
ls()
str(clusterStack[[1]])
str(clusterStack[[]])
str(clusterStack[[2]])
x=load("data/clusterStackE.coli200611061514-clean.RData")
x
ls()
ls(x)
x
x[1][[1]]
x[1]
x[2]
str(clusterStack[[2]])
str(clusterStack[[1]])
str(redExp)
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
#
## May 2008 Inferelator version 1.2#
## Bonneau lab - Aviv Madar#
#
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
rm(list=ls()) # start with a fresh workspace#
#
## main.R#
cat(file="output/log.txt","start at:",date(),"\n")#
#
inf.version <- "nwInf.1.2"#
date.nwInf.run <- date()#
#
all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
                    "ratiosEcoli-445.RData",#
                    "colMapEcoli-445.RData",                 #
                    "tfNamesEcoli-445.RData") #
#
force.reRead <- T#
add.loners <- F#
# trunc.cs <- F#
trunc.cs <- T#
# trunc.cs.i <- 900000000 ## 20#
trunc.cs.i <- 2#
#
##AM #a param to control what quantile of pval we give the priors#
lars.use.prob <- F  ##adding a boolean to determine whether or not to use lars with prior probs greeny#
alpha = 0#
	#
mod.bi.cols <- FALSE#
#
pred.subset.mode = "all"#
relevant.env <- character()#
time.mode = "all"#
#
singleInfer <- "all"#
# singleInfer <- 350#
plot.it <- TRUE#
stdRatios <- TRUE#
use.maxes <- FALSE ## Use maxes in addition to mins for interactions?#
##################  cmnd Line stuff , initializing ##################
source("R_scripts/initialize.R")#
initialize()#
dir.create( "output" )#
#
if ( ! exists("restart.kk") ) restart.kk <- 1#
#
if (force.reRead) cat ("Forced to reread in data\n")#
#
if ( file.exists( "output/nwInf.startup.RData" ) && ! force.reRead ) {#
  cat( "Reading saved initialization data...\n" )#
  old.restart.kk <- restart.kk#
  load( "output/nwInf.startup.RData" )#
  restart.kk <- old.restart.kk#
  rm( old.restart.kk )#
  initialize()#
  #
} else { ### started with arguments#
    currentHost <- system("hostname") #
    ##biclustFile <- "data/k-clust_i6_k273.clean.RData"#
    for (zz in all.data.files) load( paste("data/",zz, sep = "") )#
    rm(zz)#
    gene.ids <- rownames( ratios )#
}#
#
if (plot.it == FALSE) {#
    graphics.off()#
}
ls()
str(clusterStack[[1]])
rm(clusterStack[[1]]$redExp)
rm(clusterStack[[1]]$redExp = NA)
clusterStack[[1]]$redExp = NA
str(clusterStack[[1]])
##########################################################################################
## why not do the best clusters first?#
if (trunc.cs) {#
	clusterStack <- sort.cluster.stack( clusterStack , trunc.cs.i)#
	if ( trunc.cs.i > clusterStack$k ) {#
		trunc.cs.i <- clusterStack$k#
	}#
	clusterStack <- clusterStack[1:trunc.cs.i]#
	clusterStack$k <- trunc.cs.i#
	cat("TRUNCATING CLUSTERSTACK TO ",trunc.cs.i, " IS THIS WHAT YOU WANT TO DO????\n")#
}#
#
if ( is.null( clusterStack$k)  ) {#
	if ( length( clusterStack[[ length( clusterStack ) ]] ) == 1 ) {#
		names( clusterStack ) [ length( clusterStack ) ] <- "k"#
	} else {#
		stop( "check cluster stack ... no $k ... \n")#
	}#
}#
#
if (singleInfer > 0 && singleInfer <= clusterStack$k) {#
	cat("infferring for cluster: ", singleInfer, "\n")#
	singleInfer <- as.integer(singleInfer)#
} else {#
	cat("Fire it up! we're inferelating the whole bunch!!!\n singleInfer switch not set or greater than k \n")#
	singleInfer <- "all"#
}#
#
if (lars.use.prob == T){#
	##AM # source regDB interactions as a list of reg->genes#
	source("R_scripts/readRegDBInteractionsFromSif.R")		#
	source("R_scripts/getRegDBintoClusterStack.R")#
	for (kk in 1:clusterStack$k ) {#
		############ DEBUG code ################
		clusterStack[[kk]]$regDB <- getRegDBintoClusterStack(clusterStack[[kk]],regDB_tf_to_gene,tfNames)#
		clusterStack[[kk]]$regDBnotInClust <- clusterStack[[kk]]$regDB[which(!clusterStack[[kk]]$regDB %in% clusterStack[[kk]]$rows)]#
		##AM ## add priors into cluster stack, that way lapply can send each clust its' own priors#
		clusterStack[[kk]]$prior.names <- clusterStack[[kk]]$regDBnotInClust#
		#clusterStack[[kk]]$prior.pvals <- priorPvals[[kk]]#
		clusterStack[[kk]]$prior.pvals <- rep(1e-50,length(clusterStack[[kk]]$regDBnotInClust))#
		############ END DEBUG code ###############
	}#
}#
#
rm( kk )
str(clusterStack[[1]])
clusterStack[[1]]$redExp = NA
str(clusterStack[[1]])
##########################################################################################
  ## Read gene-expression matrix#
  ##RB, ecoli ## source("R_scripts/readExpression.R")#
  cat("preparing to standardize data\n")#
  if (stdRatios) {#
    ## currently to 0-1 with slight inflation of range for logistic regression#
    ##ratios.tmp <- standardize.row.logistic( ratios , delta.xx = 0.05)#
    ratios.tmp <- standardize.row( ratios )#
    dimnames(ratios.tmp) <- dimnames(ratios)#
    ratios <- ratios.tmp#
    rm (ratios.tmp)#
    cat("standardized ratios\n")#
  } else {#
    cat("did not standardize ratios\n")#
  }#
#
  gc()
 ## also get all regulatory influence squared away#
  ##tf.names <- getTfNames.new(file = "data/halo_NRC1transcription_factors_110804.txt", gene.ids)#
  tf.names <- tfNames[tfNames %in% rownames( ratios )]#
  rm( tfNames )#
  cat("getting list of guys that don't change significantly\n")#
  ##no.change <- lambdaFilt( lambdas, 15, mode = "names", n.thresh = 5)#
#
  ## we need to fix this !!!! RB ecoli 7/2007#
  ## aviv, you sent the already norm data, so I can't filter no change#
  no.change <- character() #
  cat("slicing tf names by changing vec\n")#
#
  tf.names.sig <- tf.names[! tf.names %in% no.change ]#
  tf.excluded <-  tf.names[ tf.names %in% no.change ]#
#
  ## precluster reg.infs#
  tf.tmp <- pre.cluster.regInfs(  tf.names.sig, ratios, cor.cut = 0.850 )#
#
  ## keep the original list of tfs that change in the prereq number of conds#
  tf.names.sig.raw <-  tf.names.sig#
  ## below we make a list of the guys that I've combined into other tfs#
  tf.removed.combined <-  tf.names.sig[! tf.names.sig %in% tf.tmp$tfs ]#
  ## now I override the surviving, more independent set of tfs (some rep more than one tf)#
  tf.names.sig <- tf.tmp$tfs#
  ## given a tf name in the new set of ind tfs who does each guy represent?#
  ## list with key being members of overwritten tf.names.sig#
  tf.combined.map <- tf.tmp$tf.cors#
  #
  ##reg.infs <- c(tf.names.sig, torsionHistone.names, env.sig)#
  env.sig <- relevant.env#
  if ( pred.subset.mode == "env" ) {#
    reg.infs <- env.sig#
  } else {#
    reg.infs <- unique( c(tf.names.sig, env.sig) )#
  }#
    #
  cat("loaded list of regulatory influences (tfs)\n")#
  cat("reg infs: \n")#
  print( reg.infs )#
  #
### add loners that change sig, and/or are TFs or other things we care#
### about. This can wait until we get the basic protocol working#
### we have to at least add loner tf's#
  if ( add.loners ) {#
    ## we could also pass this gene.ids.sig instead of tf.names.sig to add all loners#
    ##clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack, tf.names.sig, colnames(ratios) )#
    gene.ids.sig <- gene.ids[! gene.ids %in% no.change ]#
    cat( "Adding loners...\n" )#
    ##clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack, gene.ids.sig, colnames(ratios) )#
    clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack,#
                          tf.names.sig, colnames(ratios) )#
    clusterStack <- clusterStack.tmp#
    rm(clusterStack.tmp)#
  } else {#
    cat( "NOT Adding loners...\n" )#
  }#
  #
  gc()
add.loners\
add.loners
##########################################################################################
#
  ## Calculate reduced expression matrix#
  cat("Calcuting reduced expression matrix\n")#
  redExp <- reduceExpressionBiclust(ratios, clusterStack)  ## should lambdas help us reduce#
  colnames( redExp ) <- colnames( ratios )#
#
  gc()
##initialize regNet#
#
  cat("init regulatory network\n")#
  n.clust <- clusterStack$k#
  ##influence.nw <- matrix( data=0,nrow=n.clust,ncol=n.clust)#
  influence.nw <- matrix( data=0, nrow=n.clust, ncol= length( reg.infs) )#
  colnames(influence.nw) <- reg.infs#
  cv.err <- numeric()#
  tau.all <- numeric()#
  #
  is.null <- numeric()#
  select.mode <- numeric()#
  beta.0 <- numeric()#
  fraction.from.cv <- numeric()#
#
  inputs.bi <- list()#
  outputs.bi <- list()#
  cand.inf <- list()#
  coeff.inf <- list()#
  high.cor.regs <- list()#
  lars.objs <- list()#
#
  print("init cv.matrix stuff\n")#
  cv.matrix <- list()#
  cv.stdErr.matrix <- list()#
  best.s <- list()#
  frac.degFree.map <- list()#
#
  ##lm.step.list <- list()#
  ## let's skip names and use indexes for clusts for now ...#
  ##rownames(influence.nw) <- clust.names#
  ##colnames(influence.nw) <- clust.names #
#
  ##cat("KK :", kk, "\n")#
  for ( k in 1:clusterStack$k ) {#
    clusterStack[[ k ]]$k <- k#
    clusterStack[[ k ]]$redExp <- redExp[ k, ]#
  }#
  #
  fill.all.ts <- FALSE#
  fill.all.ts.frac <- 0.75 ## If >0.75 of a ts in a cluster, put the whole thang in there.#
  remove.all.ts.frac <- 0.25 ## If <0.25 of a ts in a cluster, get rid of it all.#
  ## Otherwise if there's a gap in a ts in the cols in a cluster, fill in the gap#
  fill.ts.gap.size <- 1#
#
  if ( fill.all.ts ) {#
    full.cm <- get.col.map.one.cluster( colnames( ratios ), colMap, clusterStack[[ i ]], bi.cols="all" )#
    firsts <- full.cm$is1stLast[ which( full.cm$is1stLast == "f" ) ]#
    lasts <- full.cm$is1stLast[ which( full.cm$is1stLast == "l" ) ]#
    ts <- list()#
    for ( i in 1:length( firsts ) ) {#
      start <- which( names( full.cm$is1stLast ) == names( firsts[ i ] ) )#
      end <- which( names( full.cm$is1stLast ) == names( lasts[ i ] ) )#
      ts[[ i ]] <- names( full.cm$is1stLast[ start:end ] )#
    }#
    for ( i in 1:clusterStack$k ) {#
      cols <- clusterStack[[ i ]]$cols#
      for ( j in 1:length( ts ) ) {#
        frac <- sum( ts[[ j ]] %in% cols ) / length( ts[[ j ]] )#
        ##cat("HERE:",i,j,sum( ts[[ j ]] %in% cols ),length( ts[[ j ]] ),frac,"\n")#
        if ( frac >= fill.all.ts.frac && frac < 1 ) {#
          new.cols <- ts[[ j ]][ ! ( ts[[ j ]] %in% cols ) ]#
          clusterStack[[ i ]]$cols <- unique( c( cols, new.cols ) )#
          clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
          cat( "Added", length( new.cols ), "columns to cluster", i, "(", frac, "):\n" )#
          print( new.cols )#
        } else if ( frac < remove.all.ts.frac ) {#
          remove.cols <- ts[[ j ]][ ts[[ j ]] %in% cols ]#
          clusterStack[[ i ]]$cols <- cols[ ! ( cols %in% remove.cols ) ]#
          clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
          if ( length( remove.cols ) > 0 )#
            cat( "Removed", length( remove.cols ), "columns from cluster", i, "(", frac, "):\n" )#
          print( remove.cols )#
        } else {#
          for ( q in 1:fill.ts.gap.size ) {#
            is.in <- which( ts[[ j ]] %in% cols )#
            expand <- unique( sort( c( is.in, is.in-1, is.in+1 ) ) )#
            expand <- expand[ expand > 0 & expand <= length( ts[[ j ]] ) ]#
            if ( length( unique( c( cols, ts[[ j ]][ expand ] ) ) ) - length( cols ) > 0 )#
              cat( "Added", length( unique( c( cols, ts[[ j ]][ expand ] ) ) ) -#
                  length( cols ), "columns to cluster", i, "(", frac, ")\n" )#
            clusterStack[[ i ]]$cols <- unique( c( cols, ts[[ j ]][ expand ] ) )#
            cols <- clusterStack[[ i ]]$cols#
            clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
            is.in <- expand#
          }#
        }#
      }#
    }#
  }#
#
  save.image( file="output/nwInf.startup.RData", compress=T )#
  #
#
##stop()#
#
##########################################################################################
######## NOW WE ACTUALLY DO THE CALCULATION ############ #
#
#
## cat( "Using maxes:", use.maxes, "\n" )#
#
if ( ! exists( "restart.kk" ) ) restart.kk <- 1#
endInfer <- clusterStack$k#
if ( singleInfer != "all" ) endInfer <- restart.kk <- singleInfer#
#
cat("embarking on meat of calculation ... \n woo woof moo moo!!!\n")#
#
source( "R_scripts/snow-util.R" )#
cl <- NULL#
cl.size <- length( snow.nodes )#
if ( cl.size > 1 ) cl <- init.snow.cluster( find.nodes=T )#
#
if ( ! is.null( cl ) ) {#
  gc()#
  cl.size <- length( cl )#
  ## Pass ratios and colMap to the cluster because theyre big and we only want to have to serialize them once#
  snow.export( cl, c( "ratios", "colMap", "use.maxes" ) )#
}#
#
smooth.tau <- FALSE#
#
for ( ind in seq( restart.kk, endInfer, cl.size ) ) {#
  ks <- 1:clusterStack$k#
  #
  ks2 <- ks[ ind:(ind+cl.size-1) ]#
  ks2 <- ks2[ ! is.na( ks2 ) ]#
  inds <- as.list( ks2 )#
  #
  cat( "Inferelating on biclusters:", ks2, "\n" )#
  clusters <- clusterStack[ ks2 ]#
#
################# AVIV This is meat of computation ###############
	ll <- snow.lapply( cl, clusters, infer.one.cluster, reg.infs, smooth.tau = smooth.tau, r.cutoff=0.9, time.mode = time.mode,#
						   pred.subset.mode = pred.subset.mode, lars.use.prob = lars.use.prob, alpha = alpha)#
################# END AVIV ###############
	#
  for ( ii in 1:length( inds ) ) {#
    kk <- inds[[ ii ]]#
    regInf.test <- ll[[ ii ]]$regInf.test#
#
    if ( class( regInf.test ) != "list" ) { cat( "Error: ", regInf.test, "\n" ); break }#
    #
    regInf.out <- list()#
    regInf.out[[ kk ]] <- regInf.test#
    cluster <- clusterStack[[ kk ]]#
#
    cat( "\n ... Cluster", kk, ": " )#
	if ( regInf.test$is.null ) {#
		cat( "NULL MODEL\n" )#
	} else {#
      cat( "Tau =", regInf.test$tau, "\n" )#
      nonZeroParents <- regInf.test$cand.influence[ abs(regInf.test$coeff.lars) > 0]#
      nonZeroWeights <- regInf.test$coeff.lars[ abs(regInf.test$coeff.lars) > 0]#
      cat( "\tfound nonZero weights for : ", nonZeroParents, "\n")#
      cat( "\twith weights              : ", nonZeroWeights, "\n\n")#
    }#
    #
    cv.err[kk] <- regInf.test$cv.err#
    tau.all[kk] <- regInf.test$tau#
    is.null[kk] <- regInf.test$is.null#
    beta.0[kk] <- regInf.test$intercept#
    coeff.inf[[kk]] <- regInf.test$coeff.lars#
    cand.inf[[kk]] <- regInf.test$cand.influence#
    high.cor.regs[[kk]] <- regInf.test$high.cor.regs#
    inputs.bi[[kk]] <- regInf.test$inputs#
    outputs.bi[[kk]] <- regInf.test$outputs#
    lars.objs[[kk]] <- regInf.test$lars.obj#
    if ( smooth.tau ) {#
      frac.degFree.map[[kk]] <- ll[[ ii ]]$frac.deg#
    }#
    fraction.from.cv[kk] <- regInf.test$fraction#
    ###
    cat( "filling cv for multi-tau plot\n")#
    cv.matrix[[kk]] <-  ll[[ ii ]]$cv.matrix#
    cv.stdErr.matrix[[kk]] <- ll[[ ii ]]$cv.stdErr.matrix#
    best.s[[kk]] <- ll[[ ii ]]$best.s#
#
    cv.mat <-  ll[[ ii ]]$cv.matrix#
    best.s.cv <-  ll[[ ii ]]$best.s#
    #
    save.image( file= paste( "output/nwInf.out.t", time.mode, "_pred", pred.subset.mode, ".RData", sep = ""), compress=T )#
    rm(cv.mat, best.s.cv)#
#
    rm( regInf.test, regInf.out, regInf.lmStep, reg.best )#
    gc()#
  }#
  #
  save("cand.inf","clusterStack","coeff.inf","colMap","cv.err","date.nwInf.run","gene.ids", #gene.names, knockIn ## rb Recomve ecoli#
       "inf.version","redExp","reg.infs","tau.all","beta.0", "high.cor.regs",#
       file=paste("output/nwInf.fin.t-",time.mode,"_pred-",pred.subset.mode,".RData", sep="" ), compress=T )#
  #
}#
#
if ( ! is.null( cl ) ) kill.snow.cluster( cl )#
#
##########################################################################################
############ FINISH UP / OUTPUT RESULTS #############
#
## get gene.id for each cluster such that closest to mean of cluster is rep for that cluster by name#
##    this is an area that could be imporved#
##redNamesClust <- reduceNamesExpMean( ratios, redExp, clusterStack, gene.ids)#
#
if (singleInfer == "all") {#
  ## output reg net and loners/orphans#
  save.image(file = "output/inferRunEnd.RData")#
  ##   outputRegNet(influence.nw, clusterStack, redNamesClust, mode = "all")#
  ##   outputRedExp(redExp, redNamesClust)#
} else {#
  ##   outputRegNet(influence.nw, clusterStack, redNamesClust, mode = "one", cNum = singleInfer)#
  ##   outputRedExp(redExp, redNamesClust, cNum = singleInfer)#
}#
#
##AM need to make it work for pvm#
#if( ! Sys.getenv( "HOST" )[[ 1 ]] == "Phaedra.systemsbiology.net" ) {#
#  kill.pvm()#
#}#
#q( save="no" )#
cat(file="output/log.txt","end at:",date(),"\n",append=T)
cat("cv (1): ", min.i, min.err, best.s, cv.ltest$cv[best.s], "\n")
source("main.R")
source("R_scripts/main.R")
rm(list=ls()) # start with a fresh workspace
num.single.pred = 7, num.inter.pred = 5, max.inter.corr.cutoff = 0.75
num.single.pred = 7; num.inter.pred = 5
source("R_scripts/main.R")
source("R_scripts/main.R")
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
#
## May 2008 Inferelator version 1.2#
## Bonneau lab - Aviv Madar#
#
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
rm(list=ls()) # start with a fresh workspace#
#
## main.R#
cat(file="output/log.txt","start at:",date(),"\n")#
#
inf.version <- "nwInf.1.2"#
date.nwInf.run <- date()#
#
all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
                    "ratiosEcoli-445.RData",#
                    "colMapEcoli-445.RData",                 #
                    "tfNamesEcoli-445.RData") #
#
force.reRead <- T#
add.loners <- F#
# trunc.cs <- F#
trunc.cs <- T#
# trunc.cs.i <- 900000000 ## 20#
trunc.cs.i <- 2#
#
##AM #a param to control what quantile of pval we give the priors#
lars.use.prob <- F  ##adding a boolean to determine whether or not to use lars with prior probs greeny#
alpha = 0#
	#
mod.bi.cols <- FALSE#
#
pred.subset.mode = "all"#
relevant.env <- character()#
time.mode = "all"#
#
singleInfer <- "all"#
# singleInfer <- 350#
plot.it <- TRUE#
stdRatios <- TRUE#
use.maxes <- FALSE ## Use maxes in addition to mins for interactions?#
#
# set how many predictor max you want per transcriptional unit#
num.single.pred = 7; num.inter.pred = 5#
# set correlation by which interaction predictors are filtered (if bigger)#
max.inter.corr.cutoff = 0.75#
# set correlation by which single predictors are filtered (if bigger)#
max.single.corr.cutoff = 0.9#
#
#
##################  cmnd Line stuff , initializing ##################
source("R_scripts/initialize.R")#
initialize()#
dir.create( "output" )#
#
if ( ! exists("restart.kk") ) restart.kk <- 1#
#
if (force.reRead) cat ("Forced to reread in data\n")#
#
if ( file.exists( "output/nwInf.startup.RData" ) && ! force.reRead ) {#
  cat( "Reading saved initialization data...\n" )#
  old.restart.kk <- restart.kk#
  load( "output/nwInf.startup.RData" )#
  restart.kk <- old.restart.kk#
  rm( old.restart.kk )#
  initialize()#
  #
} else { ### started with arguments#
    currentHost <- system("hostname") #
    ##biclustFile <- "data/k-clust_i6_k273.clean.RData"#
    for (zz in all.data.files) load( paste("data/",zz, sep = "") )#
    rm(zz)#
    gene.ids <- rownames( ratios )#
}#
#
if (plot.it == FALSE) {#
    graphics.off()#
}#
  #
##########################################################################################
## why not do the best clusters first?#
if (trunc.cs) {#
	clusterStack <- sort.cluster.stack( clusterStack , trunc.cs.i)#
	if ( trunc.cs.i > clusterStack$k ) {#
		trunc.cs.i <- clusterStack$k#
	}#
	clusterStack <- clusterStack[1:trunc.cs.i]#
	clusterStack$k <- trunc.cs.i#
	cat("TRUNCATING CLUSTERSTACK TO ",trunc.cs.i, " IS THIS WHAT YOU WANT TO DO????\n")#
}#
#
if ( is.null( clusterStack$k)  ) {#
	if ( length( clusterStack[[ length( clusterStack ) ]] ) == 1 ) {#
		names( clusterStack ) [ length( clusterStack ) ] <- "k"#
	} else {#
		stop( "check cluster stack ... no $k ... \n")#
	}#
}#
#
if (singleInfer > 0 && singleInfer <= clusterStack$k) {#
	cat("infferring for cluster: ", singleInfer, "\n")#
	singleInfer <- as.integer(singleInfer)#
} else {#
	cat("Fire it up! we're inferelating the whole bunch!!!\n singleInfer switch not set or greater than k \n")#
	singleInfer <- "all"#
}#
#
if (lars.use.prob == T){#
	##AM # source regDB interactions as a list of reg->genes#
	source("R_scripts/readRegDBInteractionsFromSif.R")		#
	source("R_scripts/getRegDBintoClusterStack.R")#
	for (kk in 1:clusterStack$k ) {#
		############ DEBUG code ################
		clusterStack[[kk]]$regDB <- getRegDBintoClusterStack(clusterStack[[kk]],regDB_tf_to_gene,tfNames)#
		clusterStack[[kk]]$regDBnotInClust <- clusterStack[[kk]]$regDB[which(!clusterStack[[kk]]$regDB %in% clusterStack[[kk]]$rows)]#
		##AM ## add priors into cluster stack, that way lapply can send each clust its' own priors#
		clusterStack[[kk]]$prior.names <- clusterStack[[kk]]$regDBnotInClust#
		#clusterStack[[kk]]$prior.pvals <- priorPvals[[kk]]#
		clusterStack[[kk]]$prior.pvals <- rep(1e-50,length(clusterStack[[kk]]$regDBnotInClust))#
		############ END DEBUG code ###############
	}#
}#
#
rm( kk )#
#
######### READ IN AND PREPARE DATA ##############
##########################################################################################
  ## Read gene-expression matrix#
  ##RB, ecoli ## source("R_scripts/readExpression.R")#
  cat("preparing to standardize data\n")#
  if (stdRatios) {#
    ## currently to 0-1 with slight inflation of range for logistic regression#
    ##ratios.tmp <- standardize.row.logistic( ratios , delta.xx = 0.05)#
    ratios.tmp <- standardize.row( ratios )#
    dimnames(ratios.tmp) <- dimnames(ratios)#
    ratios <- ratios.tmp#
    rm (ratios.tmp)#
    cat("standardized ratios\n")#
  } else {#
    cat("did not standardize ratios\n")#
  }#
#
  gc()#
#
#############################################################################
  ## read functions (i.e. are you a transcription factor or a kinase)#
  ## also get all regulatory influence squared away#
  ##tf.names <- getTfNames.new(file = "data/halo_NRC1transcription_factors_110804.txt", gene.ids)#
  tf.names <- tfNames[tfNames %in% rownames( ratios )]#
  rm( tfNames )#
  cat("getting list of guys that don't change significantly\n")#
  ##no.change <- lambdaFilt( lambdas, 15, mode = "names", n.thresh = 5)#
#
  ## we need to fix this !!!! RB ecoli 7/2007#
  ## aviv, you sent the already norm data, so I can't filter no change#
  no.change <- character() #
  cat("slicing tf names by changing vec\n")#
#
  tf.names.sig <- tf.names[! tf.names %in% no.change ]#
  tf.excluded <-  tf.names[ tf.names %in% no.change ]#
#
  ## precluster reg.infs#
  tf.tmp <- pre.cluster.regInfs(  tf.names.sig, ratios, cor.cut = 0.850 )#
#
  ## keep the original list of tfs that change in the prereq number of conds#
  tf.names.sig.raw <-  tf.names.sig#
  ## below we make a list of the guys that I've combined into other tfs#
  tf.removed.combined <-  tf.names.sig[! tf.names.sig %in% tf.tmp$tfs ]#
  ## now I override the surviving, more independent set of tfs (some rep more than one tf)#
  tf.names.sig <- tf.tmp$tfs#
  ## given a tf name in the new set of ind tfs who does each guy represent?#
  ## list with key being members of overwritten tf.names.sig#
  tf.combined.map <- tf.tmp$tf.cors#
  #
  ##reg.infs <- c(tf.names.sig, torsionHistone.names, env.sig)#
  env.sig <- relevant.env#
  if ( pred.subset.mode == "env" ) {#
    reg.infs <- env.sig#
  } else {#
    reg.infs <- unique( c(tf.names.sig, env.sig) )#
  }#
    #
  cat("loaded list of regulatory influences (tfs)\n")#
  cat("reg infs: \n")#
  print( reg.infs )#
  #
### add loners that change sig, and/or are TFs or other things we care#
### about. This can wait until we get the basic protocol working#
### we have to at least add loner tf's#
  if ( add.loners ) {#
    ## we could also pass this gene.ids.sig instead of tf.names.sig to add all loners#
    ##clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack, tf.names.sig, colnames(ratios) )#
    gene.ids.sig <- gene.ids[! gene.ids %in% no.change ]#
    cat( "Adding loners...\n" )#
    ##clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack, gene.ids.sig, colnames(ratios) )#
    clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack,#
                          tf.names.sig, colnames(ratios) )#
    clusterStack <- clusterStack.tmp#
    rm(clusterStack.tmp)#
  } else {#
    cat( "NOT Adding loners...\n" )#
  }#
  #
  gc()#
  #
##########################################################################################
#
  ## Calculate reduced expression matrix#
  cat("Calcuting reduced expression matrix\n")#
  redExp <- reduceExpressionBiclust(ratios, clusterStack)  #
  colnames( redExp ) <- colnames( ratios )#
#
  gc()#
##########################################################################################
  ##initialize regNet#
#
  cat("init regulatory network\n")#
  n.clust <- clusterStack$k#
  ##influence.nw <- matrix( data=0,nrow=n.clust,ncol=n.clust)#
  influence.nw <- matrix( data=0, nrow=n.clust, ncol= length( reg.infs) )#
  colnames(influence.nw) <- reg.infs#
  cv.err <- numeric()#
  tau.all <- numeric()#
  #
  is.null <- numeric()#
  select.mode <- numeric()#
  beta.0 <- numeric()#
  fraction.from.cv <- numeric()#
#
  inputs.bi <- list()#
  outputs.bi <- list()#
  cand.inf <- list()#
  coeff.inf <- list()#
  high.cor.regs <- list()#
  lars.objs <- list()#
#
  print("init cv.matrix stuff\n")#
  cv.matrix <- list()#
  cv.stdErr.matrix <- list()#
  best.s <- list()#
  frac.degFree.map <- list()#
#
  ##lm.step.list <- list()#
  ## let's skip names and use indexes for clusts for now ...#
  ##rownames(influence.nw) <- clust.names#
  ##colnames(influence.nw) <- clust.names #
#
  ##cat("KK :", kk, "\n")#
  for ( k in 1:clusterStack$k ) {#
    clusterStack[[ k ]]$k <- k#
    clusterStack[[ k ]]$redExp <- redExp[ k, ]#
  }#
  #
  fill.all.ts <- FALSE#
  fill.all.ts.frac <- 0.75 ## If >0.75 of a ts in a cluster, put the whole thang in there.#
  remove.all.ts.frac <- 0.25 ## If <0.25 of a ts in a cluster, get rid of it all.#
  ## Otherwise if there's a gap in a ts in the cols in a cluster, fill in the gap#
  fill.ts.gap.size <- 1#
#
  if ( fill.all.ts ) {#
    full.cm <- get.col.map.one.cluster( colnames( ratios ), colMap, clusterStack[[ i ]], bi.cols="all" )#
    firsts <- full.cm$is1stLast[ which( full.cm$is1stLast == "f" ) ]#
    lasts <- full.cm$is1stLast[ which( full.cm$is1stLast == "l" ) ]#
    ts <- list()#
    for ( i in 1:length( firsts ) ) {#
      start <- which( names( full.cm$is1stLast ) == names( firsts[ i ] ) )#
      end <- which( names( full.cm$is1stLast ) == names( lasts[ i ] ) )#
      ts[[ i ]] <- names( full.cm$is1stLast[ start:end ] )#
    }#
    for ( i in 1:clusterStack$k ) {#
      cols <- clusterStack[[ i ]]$cols#
      for ( j in 1:length( ts ) ) {#
        frac <- sum( ts[[ j ]] %in% cols ) / length( ts[[ j ]] )#
        ##cat("HERE:",i,j,sum( ts[[ j ]] %in% cols ),length( ts[[ j ]] ),frac,"\n")#
        if ( frac >= fill.all.ts.frac && frac < 1 ) {#
          new.cols <- ts[[ j ]][ ! ( ts[[ j ]] %in% cols ) ]#
          clusterStack[[ i ]]$cols <- unique( c( cols, new.cols ) )#
          clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
          cat( "Added", length( new.cols ), "columns to cluster", i, "(", frac, "):\n" )#
          print( new.cols )#
        } else if ( frac < remove.all.ts.frac ) {#
          remove.cols <- ts[[ j ]][ ts[[ j ]] %in% cols ]#
          clusterStack[[ i ]]$cols <- cols[ ! ( cols %in% remove.cols ) ]#
          clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
          if ( length( remove.cols ) > 0 )#
            cat( "Removed", length( remove.cols ), "columns from cluster", i, "(", frac, "):\n" )#
          print( remove.cols )#
        } else {#
          for ( q in 1:fill.ts.gap.size ) {#
            is.in <- which( ts[[ j ]] %in% cols )#
            expand <- unique( sort( c( is.in, is.in-1, is.in+1 ) ) )#
            expand <- expand[ expand > 0 & expand <= length( ts[[ j ]] ) ]#
            if ( length( unique( c( cols, ts[[ j ]][ expand ] ) ) ) - length( cols ) > 0 )#
              cat( "Added", length( unique( c( cols, ts[[ j ]][ expand ] ) ) ) -#
                  length( cols ), "columns to cluster", i, "(", frac, ")\n" )#
            clusterStack[[ i ]]$cols <- unique( c( cols, ts[[ j ]][ expand ] ) )#
            cols <- clusterStack[[ i ]]$cols#
            clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
            is.in <- expand#
          }#
        }#
      }#
    }#
  }#
#
  save.image( file="output/nwInf.startup.RData", compress=T )#
  #
#
##stop()#
#
##########################################################################################
######## NOW WE ACTUALLY DO THE CALCULATION ############ #
#
#
## cat( "Using maxes:", use.maxes, "\n" )#
#
if ( ! exists( "restart.kk" ) ) restart.kk <- 1#
endInfer <- clusterStack$k#
if ( singleInfer != "all" ) endInfer <- restart.kk <- singleInfer#
#
cat("embarking on meat of calculation ... \n woo woof moo moo!!!\n")#
#
source( "R_scripts/snow-util.R" )#
cl <- NULL#
cl.size <- length( snow.nodes )#
if ( cl.size > 1 ) cl <- init.snow.cluster( find.nodes=T )#
#
if ( ! is.null( cl ) ) {#
  gc()#
  cl.size <- length( cl )#
  ## Pass ratios and colMap to the cluster because theyre big and we only want to have to serialize them once#
  snow.export( cl, c( "ratios", "colMap", "use.maxes" ) )#
}#
#
smooth.tau <- FALSE
seq( restart.kk, endInfer, cl.size )
ind=1
  ks <- 1:clusterStack$k#
  #
  ks2 <- ks[ ind:(ind+cl.size-1) ]#
  ks2 <- ks2[ ! is.na( ks2 ) ]#
  inds <- as.list( ks2 )#
  #
  cat( "Inferelating on biclusters:", ks2, "\n" )#
  clusters <- clusterStack[ ks2 ]
r.cutoff=max.single.corr.cutoff
cluster =clusters[[1]]
no.inf.cluster.members=T
assNeibs=NA
smooth.tau
time.mode
pred.subset.mode
 ## Smooth.tau = T tries a bazillion taus (5:50) so as to make#
#
  ## we only do the screening of all 1s and 2s with a few taus even if smooth.tau = T#
  tau.tries <- 15 #c( 20, 10, 5 ) ## c(25,15,5)#
  #cluster$cols <- gsub( "\\.", "-", cluster$cols, extended=F )#
  #
  if ( is.null( cluster$redExp ) ) cluster$redExp <- reduceExpression.single.clust( ratios, cluster )#
#
  cluster.col.map <- get.col.map.one.cluster( colnames( ratios ), colMap, cluster=cluster )#
      #
  if ( is.null( cluster$k ) ) cluster$k <- 9999#
#
  cat(file="output/log.txt","Starting reg.Influence: cluster", cluster$k, "\n", date() , "\n",append=T)#
  cat("time mode is: ", time.mode,"\n")#
  cat("predictor subset mode is: ", pred.subset.mode,"\n")#
#
  cat(length( reg.infs ), " TFs with significant change (or env) \n")
 ## Get rid of 0-variance influences (i.e. env factors)#
  var.exclude <- 0.01#
  tmp <- apply( ratios[ reg.infs, cluster$cols ], 1, var, na.rm=T )#
  names( tmp ) <- reg.infs#
  ##tmp.2 <- apply( ratios[ reg.infs, ], 1, function(i) sum( i != min(i) ) )#
  if ( any( is.na( tmp ) | tmp <= var.exclude ) )#
    cat( "Excluding tfs", reg.infs[ which( is.na( tmp ) | tmp <= var.exclude ) ], "with var <=", var.exclude, "\n" )#
  #
  tmp.r <- reg.infs[! (reg.infs %in% cluster$rows) & ( is.na( tmp ) | tmp > var.exclude ) ]#
  cat( length( tmp.r ), " TFs not in this clust\n")#
  if ( ! no.inf.cluster.members ) {#
    cat( "Inferring on all TFs, including those in the cluster.\n" )#
  } else {#
    cat( "Inferring on only TFs not in the cluster.\n" )#
    reg.infs <- tmp.r#
  }
 ## Get rid of highly-correlated influences not in cluster#
  redExp.tmp <- cluster$redExp[ cluster$cols ]#
  rats <- ratios[ reg.infs, cluster$cols ]#
  cors <- apply( rats, 1, cor, redExp.tmp, use="pairwise" )#
  correlated <- names( which( cors > r.cutoff ) )#
  cat( "These regulators are highly correlated w/ the cluster (cutoff=", r.cutoff, "):\n" )#
  print( cors[ correlated ] )#
  cat( "Removing them from the list of reg infs\n" )#
  reg.infs <- reg.infs[ ! reg.infs %in% correlated ]#
  cat( "Inferring on", length( reg.infs ), "influences.\n" )#
  rm( redExp.tmp )#
  high.cor.regs <- correlated#
#
  best1s <- character()#
  best2s <- list()
1:length( tau.tries )\
1:length( tau.tries )
tau.try.i=1
cat( "\n\n1and2s: Tau =", tau.tries[ tau.try.i ], "\n" )  #
	##AM # this step takes all the time in the inferelator run (making it more efficient? changing it?)#
    if ( pred.subset.mode == "env") {#
      reg.best <- regulatoryInfluencesClust.1and2s.env( ratios[reg.infs,],  reg.infs,#
                                                       cluster = cluster, colMap=colMap,#
                                                       cluster.col.map=cluster.col.map,#
                                                       assNeibs = NA ,  tau = tau.tries[ tau.try.i ],#
                                                       time.mode = time.mode, int.mode = "all")#
      cat("done with regulatoryInfluencesClust.1and2s.env\n")#
    } else {#
      reg.best <- regulatoryInfluencesClust.1and2s( ratios[reg.infs,],  reg.infs,#
                                                   cluster = cluster, colMap=colMap,#
                                                   cluster.col.map=cluster.col.map,#
                                                   assNeibs = NA ,  tau = tau.tries[ tau.try.i ],#
                                                   time.mode = time.mode, pred.subset.mode = pred.subset.mode,#
                                                   max.inter.corr.cutoff = max.inter.corr.cutoff)#
#
      cat("done with regulatoryInfluencesClust.1and2s\n")#
    }#
    best1s <- c( best1s, reg.best$Best1s )#
    best2s[[ tau.try.i ]] <- reg.best$Best2s #
  }
  #
  best.1.2 = list()#
  best.1.2$best2s = best2s[[1]]#
  best.1.2$best1s = best1s#
  cat("putative predictors for transcription unit:", cluster$k, "\n")  #
  cat("**best single predictors**\n") #
  print( best.1.2$best1s )  #
  cat("**best min interaction predictors**\n")#
  print( best.1.2$best2s )
if ( smooth.tau ) {#
    tau.tries <- seq(0.25, 25, 0.1)#
    tau.iter <- 1#
    cv.matrix <- matrix(, nrow = length(tau.tries), ncol = 100) ## assuming length = 100 in cv.lars call (default)#
    cv.stdErr.matrix <-  matrix(, nrow = length(tau.tries), ncol = 100)#
    best.s <- rep(1, length(tau.tries))#
    rownames(cv.matrix) <- tau.tries#
    colnames(cv.matrix) <- round( seq(0,100, length = 100), 4)#
  }else {#
    tau.tries <- c(15, 12, 10, 7) ##, 1:50#
    tau.iter <- 1#
    cv.matrix <- matrix(, nrow = length(tau.tries), ncol = 100) ## assuming length = 100 in cv.lars call (default)#
    cv.stdErr.matrix <-  matrix(, nrow = length(tau.tries), ncol = 100)#
    best.s <- rep(1, length(tau.tries))#
    rownames(cv.matrix) <- tau.tries#
    colnames(cv.matrix) <- round( seq(0,100, length = 100), 4)#
  }#
#
  #regInfs.f <- li
tau.tries
tau.try=15
   tau.i <- which( tau.tries == tau.try )#
    cat( "\n\nmodfit.lars, no cv.min: Tau =", tau.try, "\n" )#
    best.1.2$best1s <- best.1.2$best1s[ best.1.2$best1s %in% rownames( ratios ) ]#
	#cat ( "new ones : ",  best.1.2$best1s, "\n")#
#
    ##modify below greeny#
    ##pass in  lars.probs#
##AM # need to fix the names returned for the non-zero weights as prior names return as NA  #
		  regInf.test <- regulatoryInfluencesClust.modFit.lars( ratios[reg.infs,],  reg.infs,#
																cluster = cluster, colMap=colMap,#
																best.1.2$best1s , best.1.2$best2s, tau=tau.try,#
																cluster.col.map=cluster.col.map,#
																assNeibs=NA, plot.it=TRUE, cv.min=FALSE,#
																max.tau.iter = tau.iter,#
																time.mode = time.mode,#
																lars.use.prob = lars.use.prob, alpha=alpha )
   if (smooth.tau && tau.i == 1) {#
      num.deg.ols <-  dim(regInf.test$lars.obj$beta)[1]  ## num deg + 1 (by index with 0 included)#
      cat("number of deg: ", num.deg.ols, " iter ", tau.i, "\n")#
      frac.deg <- matrix(1.0, nrow = length(tau.tries), ncol = num.deg.ols )#
      frac.deg[tau.i, ] <- apply( abs( regInf.test$lars.obj$beta ), 1, sum) /#
        sum(abs( regInf.test$lars.obj$beta[num.deg.ols,]  ) )#
    } else if (smooth.tau) {#
      num.deg.ols.tmp <-  dim(regInf.test$lars.obj$beta)[1]#
      num.d <- min(num.deg.ols.tmp, num.deg.ols)#
      cat("number of deg: ", num.deg.ols.tmp, " iter ", tau.i, "\n")#
      #pause()#
      frac.deg[tau.i, 1:num.d ] <- apply( abs( regInf.test$lars.obj$beta[1:num.d,] ), 1, sum) /#
        sum(abs( regInf.test$lars.obj$beta[num.deg.ols.tmp,]  ) )#
    }#
    ##select.mode[kk] <- 1#
    regInf.test$select.mode <- 1#
    #regInfs.f[[ tau.i ]] <- regInf.test#
    if (smooth.tau == FALSE && regInf.test$is.null == FALSE ) break ##return( regInf.test ) ##{ break }#
    ##if (smooth.tau == TRUE) {#
    cv.matrix[tau.i, ]        <- regInf.test$cv.obj$cv#
    cv.stdErr.matrix[tau.i, ] <- regInf.test$cv.obj$cv.error#
    best.s[tau.i] <- regInf.test$best.s#
    ##}#
  }
source("R_scripts/main.R")
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
#
## May 2008 Inferelator version 1.2#
## Bonneau lab - Aviv Madar#
#
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
rm(list=ls()) # start with a fresh workspace#
#
## main.R#
cat(file="output/log.txt","start at:",date(),"\n")#
#
inf.version <- "nwInf.1.2"#
date.nwInf.run <- date()#
#
all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
                    "ratiosEcoli-445.RData",#
                    "colMapEcoli-445.RData",                 #
                    "tfNamesEcoli-445.RData") #
#
force.reRead <- T#
add.loners <- F#
# trunc.cs <- F#
trunc.cs <- T#
# trunc.cs.i <- 900000000 ## 20#
trunc.cs.i <- 2#
#
##AM #a param to control what quantile of pval we give the priors#
lars.use.prob <- F  ##adding a boolean to determine whether or not to use lars with prior probs greeny#
alpha = 0#
	#
mod.bi.cols <- FALSE#
#
pred.subset.mode = "all"#
relevant.env <- character()#
time.mode = "all"#
#
singleInfer <- "all"#
# singleInfer <- 350#
plot.it <- TRUE#
stdRatios <- TRUE#
use.maxes <- FALSE ## Use maxes in addition to mins for interactions?#
#
# set how many predictor max you want per transcriptional unit#
num.single.pred = 7; num.inter.pred = 5#
# set correlation by which interaction predictors are filtered (if bigger)#
max.inter.corr.cutoff = 0.75#
# set correlation by which single predictors are filtered (if bigger)#
max.single.corr.cutoff = 0.9#
#
#
##################  cmnd Line stuff , initializing ##################
source("R_scripts/initialize.R")#
initialize()#
dir.create( "output" )#
#
if ( ! exists("restart.kk") ) restart.kk <- 1#
#
if (force.reRead) cat ("Forced to reread in data\n")#
#
if ( file.exists( "output/nwInf.startup.RData" ) && ! force.reRead ) {#
  cat( "Reading saved initialization data...\n" )#
  old.restart.kk <- restart.kk#
  load( "output/nwInf.startup.RData" )#
  restart.kk <- old.restart.kk#
  rm( old.restart.kk )#
  initialize()#
  #
} else { ### started with arguments#
    currentHost <- system("hostname") #
    ##biclustFile <- "data/k-clust_i6_k273.clean.RData"#
    for (zz in all.data.files) load( paste("data/",zz, sep = "") )#
    rm(zz)#
    gene.ids <- rownames( ratios )#
}#
#
if (plot.it == FALSE) {#
    graphics.off()#
}#
  #
##########################################################################################
## why not do the best clusters first?#
if (trunc.cs) {#
	clusterStack <- sort.cluster.stack( clusterStack , trunc.cs.i)#
	if ( trunc.cs.i > clusterStack$k ) {#
		trunc.cs.i <- clusterStack$k#
	}#
	clusterStack <- clusterStack[1:trunc.cs.i]#
	clusterStack$k <- trunc.cs.i#
	cat("TRUNCATING CLUSTERSTACK TO ",trunc.cs.i, " IS THIS WHAT YOU WANT TO DO????\n")#
}#
#
if ( is.null( clusterStack$k)  ) {#
	if ( length( clusterStack[[ length( clusterStack ) ]] ) == 1 ) {#
		names( clusterStack ) [ length( clusterStack ) ] <- "k"#
	} else {#
		stop( "check cluster stack ... no $k ... \n")#
	}#
}#
#
if (singleInfer > 0 && singleInfer <= clusterStack$k) {#
	cat("infferring for cluster: ", singleInfer, "\n")#
	singleInfer <- as.integer(singleInfer)#
} else {#
	cat("Fire it up! we're inferelating the whole bunch!!!\n singleInfer switch not set or greater than k \n")#
	singleInfer <- "all"#
}#
#
if (lars.use.prob == T){#
	##AM # source regDB interactions as a list of reg->genes#
	source("R_scripts/readRegDBInteractionsFromSif.R")		#
	source("R_scripts/getRegDBintoClusterStack.R")#
	for (kk in 1:clusterStack$k ) {#
		############ DEBUG code ################
		clusterStack[[kk]]$regDB <- getRegDBintoClusterStack(clusterStack[[kk]],regDB_tf_to_gene,tfNames)#
		clusterStack[[kk]]$regDBnotInClust <- clusterStack[[kk]]$regDB[which(!clusterStack[[kk]]$regDB %in% clusterStack[[kk]]$rows)]#
		##AM ## add priors into cluster stack, that way lapply can send each clust its' own priors#
		clusterStack[[kk]]$prior.names <- clusterStack[[kk]]$regDBnotInClust#
		#clusterStack[[kk]]$prior.pvals <- priorPvals[[kk]]#
		clusterStack[[kk]]$prior.pvals <- rep(1e-50,length(clusterStack[[kk]]$regDBnotInClust))#
		############ END DEBUG code ###############
	}#
	rm( kk )#
}#
#
#
#
######### READ IN AND PREPARE DATA ##############
##########################################################################################
  ## Read gene-expression matrix#
  ##RB, ecoli ## source("R_scripts/readExpression.R")#
  cat("preparing to standardize data\n")#
  if (stdRatios) {#
    ## currently to 0-1 with slight inflation of range for logistic regression#
    ##ratios.tmp <- standardize.row.logistic( ratios , delta.xx = 0.05)#
    ratios.tmp <- standardize.row( ratios )#
    dimnames(ratios.tmp) <- dimnames(ratios)#
    ratios <- ratios.tmp#
    rm (ratios.tmp)#
    cat("standardized ratios\n")#
  } else {#
    cat("did not standardize ratios\n")#
  }#
#
  gc()#
#
#############################################################################
  ## read functions (i.e. are you a transcription factor or a kinase)#
  ## also get all regulatory influence squared away#
  ##tf.names <- getTfNames.new(file = "data/halo_NRC1transcription_factors_110804.txt", gene.ids)#
  tf.names <- tfNames[tfNames %in% rownames( ratios )]#
  rm( tfNames )#
  cat("getting list of guys that don't change significantly\n")#
  ##no.change <- lambdaFilt( lambdas, 15, mode = "names", n.thresh = 5)#
#
  ## we need to fix this !!!! RB ecoli 7/2007#
  ## aviv, you sent the already norm data, so I can't filter no change#
  no.change <- character() #
  cat("slicing tf names by changing vec\n")#
#
  tf.names.sig <- tf.names[! tf.names %in% no.change ]#
  tf.excluded <-  tf.names[ tf.names %in% no.change ]#
#
  ## precluster reg.infs#
  tf.tmp <- pre.cluster.regInfs(  tf.names.sig, ratios, cor.cut = 0.850 )#
#
  ## keep the original list of tfs that change in the prereq number of conds#
  tf.names.sig.raw <-  tf.names.sig#
  ## below we make a list of the guys that I've combined into other tfs#
  tf.removed.combined <-  tf.names.sig[! tf.names.sig %in% tf.tmp$tfs ]#
  ## now I override the surviving, more independent set of tfs (some rep more than one tf)#
  tf.names.sig <- tf.tmp$tfs#
  ## given a tf name in the new set of ind tfs who does each guy represent?#
  ## list with key being members of overwritten tf.names.sig#
  tf.combined.map <- tf.tmp$tf.cors#
  #
  ##reg.infs <- c(tf.names.sig, torsionHistone.names, env.sig)#
  env.sig <- relevant.env#
  if ( pred.subset.mode == "env" ) {#
    reg.infs <- env.sig#
  } else {#
    reg.infs <- unique( c(tf.names.sig, env.sig) )#
  }#
    #
  cat("loaded list of regulatory influences (tfs)\n")#
  cat("reg infs: \n")#
  print( reg.infs )#
  #
### add loners that change sig, and/or are TFs or other things we care#
### about. This can wait until we get the basic protocol working#
### we have to at least add loner tf's#
  if ( add.loners ) {#
    ## we could also pass this gene.ids.sig instead of tf.names.sig to add all loners#
    ##clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack, tf.names.sig, colnames(ratios) )#
    gene.ids.sig <- gene.ids[! gene.ids %in% no.change ]#
    cat( "Adding loners...\n" )#
    ##clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack, gene.ids.sig, colnames(ratios) )#
    clusterStack.tmp <- addLonerTFs.toClusterStack(clusterStack,#
                          tf.names.sig, colnames(ratios) )#
    clusterStack <- clusterStack.tmp#
    rm(clusterStack.tmp)#
  } else {#
    cat( "NOT Adding loners...\n" )#
  }#
  #
  gc()#
  #
##########################################################################################
#
  ## Calculate reduced expression matrix#
  cat("Calcuting reduced expression matrix\n")#
  redExp <- reduceExpressionBiclust(ratios, clusterStack)  #
  colnames( redExp ) <- colnames( ratios )#
#
  gc()#
##########################################################################################
  ##initialize regNet#
#
  cat("init regulatory network\n")#
  n.clust <- clusterStack$k#
  ##influence.nw <- matrix( data=0,nrow=n.clust,ncol=n.clust)#
  influence.nw <- matrix( data=0, nrow=n.clust, ncol= length( reg.infs) )#
  colnames(influence.nw) <- reg.infs#
  cv.err <- numeric()#
  tau.all <- numeric()#
  #
  is.null <- numeric()#
  select.mode <- numeric()#
  beta.0 <- numeric()#
  fraction.from.cv <- numeric()#
#
  inputs.bi <- list()#
  outputs.bi <- list()#
  cand.inf <- list()#
  coeff.inf <- list()#
  high.cor.regs <- list()#
  lars.objs <- list()#
#
  print("init cv.matrix stuff\n")#
  cv.matrix <- list()#
  cv.stdErr.matrix <- list()#
  best.s <- list()#
  frac.degFree.map <- list()#
#
  ##lm.step.list <- list()#
  ## let's skip names and use indexes for clusts for now ...#
  ##rownames(influence.nw) <- clust.names#
  ##colnames(influence.nw) <- clust.names #
#
  ##cat("KK :", kk, "\n")#
  for ( k in 1:clusterStack$k ) {#
    clusterStack[[ k ]]$k <- k#
    clusterStack[[ k ]]$redExp <- redExp[ k, ]#
  }#
  #
  fill.all.ts <- FALSE#
  fill.all.ts.frac <- 0.75 ## If >0.75 of a ts in a cluster, put the whole thang in there.#
  remove.all.ts.frac <- 0.25 ## If <0.25 of a ts in a cluster, get rid of it all.#
  ## Otherwise if there's a gap in a ts in the cols in a cluster, fill in the gap#
  fill.ts.gap.size <- 1#
#
  if ( fill.all.ts ) {#
    full.cm <- get.col.map.one.cluster( colnames( ratios ), colMap, clusterStack[[ i ]], bi.cols="all" )#
    firsts <- full.cm$is1stLast[ which( full.cm$is1stLast == "f" ) ]#
    lasts <- full.cm$is1stLast[ which( full.cm$is1stLast == "l" ) ]#
    ts <- list()#
    for ( i in 1:length( firsts ) ) {#
      start <- which( names( full.cm$is1stLast ) == names( firsts[ i ] ) )#
      end <- which( names( full.cm$is1stLast ) == names( lasts[ i ] ) )#
      ts[[ i ]] <- names( full.cm$is1stLast[ start:end ] )#
    }#
    for ( i in 1:clusterStack$k ) {#
      cols <- clusterStack[[ i ]]$cols#
      for ( j in 1:length( ts ) ) {#
        frac <- sum( ts[[ j ]] %in% cols ) / length( ts[[ j ]] )#
        ##cat("HERE:",i,j,sum( ts[[ j ]] %in% cols ),length( ts[[ j ]] ),frac,"\n")#
        if ( frac >= fill.all.ts.frac && frac < 1 ) {#
          new.cols <- ts[[ j ]][ ! ( ts[[ j ]] %in% cols ) ]#
          clusterStack[[ i ]]$cols <- unique( c( cols, new.cols ) )#
          clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
          cat( "Added", length( new.cols ), "columns to cluster", i, "(", frac, "):\n" )#
          print( new.cols )#
        } else if ( frac < remove.all.ts.frac ) {#
          remove.cols <- ts[[ j ]][ ts[[ j ]] %in% cols ]#
          clusterStack[[ i ]]$cols <- cols[ ! ( cols %in% remove.cols ) ]#
          clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
          if ( length( remove.cols ) > 0 )#
            cat( "Removed", length( remove.cols ), "columns from cluster", i, "(", frac, "):\n" )#
          print( remove.cols )#
        } else {#
          for ( q in 1:fill.ts.gap.size ) {#
            is.in <- which( ts[[ j ]] %in% cols )#
            expand <- unique( sort( c( is.in, is.in-1, is.in+1 ) ) )#
            expand <- expand[ expand > 0 & expand <= length( ts[[ j ]] ) ]#
            if ( length( unique( c( cols, ts[[ j ]][ expand ] ) ) ) - length( cols ) > 0 )#
              cat( "Added", length( unique( c( cols, ts[[ j ]][ expand ] ) ) ) -#
                  length( cols ), "columns to cluster", i, "(", frac, ")\n" )#
            clusterStack[[ i ]]$cols <- unique( c( cols, ts[[ j ]][ expand ] ) )#
            cols <- clusterStack[[ i ]]$cols#
            clusterStack[[ i ]]$ncols <- length( clusterStack[[ i ]]$cols )#
            is.in <- expand#
          }#
        }#
      }#
    }#
  }#
#
  save.image( file="output/nwInf.startup.RData", compress=T )#
  #
#
##stop()#
#
##########################################################################################
######## NOW WE ACTUALLY DO THE CALCULATION ############ #
#
#
## cat( "Using maxes:", use.maxes, "\n" )#
#
if ( ! exists( "restart.kk" ) ) restart.kk <- 1#
endInfer <- clusterStack$k#
if ( singleInfer != "all" ) endInfer <- restart.kk <- singleInfer#
#
cat("embarking on meat of calculation ... \n woo woof moo moo!!!\n")#
#
source( "R_scripts/snow-util.R" )#
cl <- NULL#
cl.size <- length( snow.nodes )#
if ( cl.size > 1 ) cl <- init.snow.cluster( find.nodes=T )#
#
if ( ! is.null( cl ) ) {#
  gc()#
  cl.size <- length( cl )#
  ## Pass ratios and colMap to the cluster because theyre big and we only want to have to serialize them once#
  snow.export( cl, c( "ratios", "colMap", "use.maxes" ) )#
}#
#
smooth.tau <- FALSE
ind=1
ks <- 1:clusterStack$k#
  #
  ks2 <- ks[ ind:(ind+cl.size-1) ]#
  ks2 <- ks2[ ! is.na( ks2 ) ]#
  inds <- as.list( ks2 )#
  #
  cat( "Inferelating on biclusters:", ks2, "\n" )#
  clusters <- clusterStack[ ks2 ]
ll <- snow.lapply( cl, clusters, infer.one.cluster, reg.infs, smooth.tau = smooth.tau, #
						r.cutoff=max.single.corr.cutoff, max.inter.corr.cutoff = max.inter.corr.cutoff, time.mode = time.mode,#
						pred.subset.mode = pred.subset.mode, lars.use.prob = lars.use.prob, alpha = alpha)
ll <- snow.lapply( cl, clusters, infer.one.cluster, reg.infs, smooth.tau = smooth.tau, #
						r.cutoff=max.single.corr.cutoff, max.inter.corr.cutoff = max.inter.corr.cutoff, time.mode = time.mode,#
						pred.subset.mode = pred.subset.mode, lars.use.prob = lars.use.prob, alpha = alpha)
source("R_scripts/infer.one.cluster.R")
ll <- snow.lapply( cl, clusters, infer.one.cluster, reg.infs, smooth.tau = smooth.tau, #
						r.cutoff=max.single.corr.cutoff, max.inter.corr.cutoff = max.inter.corr.cutoff, time.mode = time.mode,#
						pred.subset.mode = pred.subset.mode, lars.use.prob = lars.use.prob, alpha = alpha)
source("R_scripts/infer.one.cluster.R")
source("R_scripts/main.R")
rm(list=ls())
load("../tags/working_run_for_halo_cell_paper/clusterStack-fromInfPap-forBig.RData")
ls()
str(clusterStack[[1]])
load("/Users/aviv/Documents/nyu/bonneauLab/inferelator/trunk/data/clusterStackE.coli200611061514-clean.RData")
str(clusterStack[[1]])
load("../tags/working_run_for_halo_cell_paper/clusterStack-fromInfPap-forBig.RData")
str(clusterStack[[1]])
save(clusterStack,"data/clusterStackHalo.RData")
save(clusterStack,file="data/clusterStackHalo.RData")
clusterStack[[76]]
str(clusterStack[[76]])
load("../tags/working_run_for_halo_cell_paper/colMap-445-clean.RData")
str(colMap[[1]])
str(colMap[[450]])
str(colMap[[445]])
str(colMap[[446]])
str(colMap[[447]])
str(colMap[[4454]])
str(colMap[[445]])
save(colMap,file="data/colMapHalo-445.RData")
load("../tags/working_run_for_halo_cell_paper/ratios-445-halo.RData")
str(ratios)
save(ratios,file="data/ratiosHalo-445.RData")
load("../tags/working_run_for_halo_cell_paper/output/")
load("../tags/working_run_for_halo_cell_paper/output/nwInf.out.tall_predall.RData")
tf.names
tf.names.sig
unique(tf.names)
rm(list=ls())
load("data/tfNamesEcoli-445.RData")
ls()
rm(list=ls())
load("../tags/working_run_for_halo_cell_paper/output/nwInf.out.tall_predall.RData")
tfNames = unique(tf.names)
save(tfNames,file="data/tfNamesHalo.RData")
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
#
## May 2008 Inferelator version 1.2#
## Bonneau lab - Aviv Madar#
#
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
rm(list=ls()) # start with a fresh workspace#
#
## main.R#
# keep a log file#
cat(file="output/log.txt","start at:",date(),"\n")#
inf.version <- "nwInf.1.2"#
date.nwInf.run <- date()#
#
#////////////////// USER PARAMS #//////////////////#
# trunc.cs <- F#
trunc.cs <- T#
# trunc.cs.i <- 900000000 ## 20#
trunc.cs.i <- 2#
#
#
mod.bi.cols <- FALSE#
plot.it <- TRUE#
#
singleInfer <- "all" # singleInfer <- 350#
#
# set how many predictor max you want per transcriptional unit#
num.single.pred = 7; num.inter.pred = 5#
# set correlation by which interaction predictors are filtered (if bigger)#
max.inter.corr.cutoff = 0.75#
# set correlation by which single predictors are filtered (if bigger)#
max.single.corr.cutoff = 0.9#
# set the time scale (should be around the expected half life of mRNA in minutes)#
tau=15#
#
#////////////////// USER ADVANCED PARAMS #//////////////////#
##AM #a param to control what quantile of pval we give the priors#
lars.use.prob <- F  ##adding a boolean to determine whether or not to use lars with prior probs greeny#
alpha = 0#
time.mode = "all"#
relevant.env <- character()#
pred.subset.mode = "all"#
stdRatios <- TRUE#
force.reRead <- T#
add.loners <- F#
use.maxes <- FALSE ## Use maxes in addition to mins for interactions?#
#
##################  cmnd Line stuff , initializing ##################
#
all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
                    "ratiosEcoli-445.RData",#
                    "colMapEcoli-445.RData",                 #
                    "tfNamesEcoli-445.RData") #
                    #
all.data.files <- c("clusterStackHalo.RData",   #
                    "ratiosHalo-445.RData",#
                    "colMapHalo-445.RData",                 #
                    "tfNamesHalo.RData") #
#
#
source("R_scripts/initialize.R")#
initialize()#
dir.create( "output" )#
#
if ( ! exists("restart.kk") ) restart.kk <- 1#
#
if (force.reRead) cat ("Forced to reread in data\n")#
#
if ( file.exists( "output/nwInf.startup.RData" ) && ! force.reRead ) {#
  cat( "Reading saved initialization data...\n" )#
  old.restart.kk <- restart.kk#
  load( "output/nwInf.startup.RData" )#
  restart.kk <- old.restart.kk#
  rm( old.restart.kk )#
  initialize()#
  #
} else { ### started with arguments#
    currentHost <- system("hostname") #
    ##biclustFile <- "data/k-clust_i6_k273.clean.RData"#
    for (zz in all.data.files) load( paste("data/",zz, sep = "") )#
    rm(zz)#
    gene.ids <- rownames( ratios )#
}#
#
if (plot.it == FALSE) {#
    graphics.off()#
}#
  #
##########################################################################################
## why not do the best clusters first?#
if (trunc.cs) {#
	clusterStack <- sort.cluster.stack( clusterStack , trunc.cs.i)#
	if ( trunc.cs.i > clusterStack$k ) {#
		trunc.cs.i <- clusterStack$k#
	}#
	clusterStack <- clusterStack[1:trunc.cs.i]#
	clusterStack$k <- trunc.cs.i#
	cat("TRUNCATING CLUSTERSTACK TO ",trunc.cs.i, " IS THIS WHAT YOU WANT TO DO????\n")#
}#
#
if ( is.null( clusterStack$k)  ) {#
	if ( length( clusterStack[[ length( clusterStack ) ]] ) == 1 ) {#
		names( clusterStack ) [ length( clusterStack ) ] <- "k"#
	} else {#
		stop( "check cluster stack ... no $k ... \n")#
	}#
}#
#
if (singleInfer > 0 && singleInfer <= clusterStack$k) {#
	cat("infferring for cluster: ", singleInfer, "\n")#
	singleInfer <- as.integer(singleInfer)#
} else {#
	cat("Fire it up! we're inferelating the whole bunch!!!\n singleInfer switch not set or greater than k \n")#
	singleInfer <- "all"#
}#
#
if (lars.use.prob == T){#
	##AM # source regDB interactions as a list of reg->genes#
	source("R_scripts/readRegDBInteractionsFromSif.R")		#
	source("R_scripts/getRegDBintoClusterStack.R")#
	for (kk in 1:clusterStack$k ) {#
		############ DEBUG code ################
		clusterStack[[kk]]$regDB <- getRegDBintoClusterStack(clusterStack[[kk]],regDB_tf_to_gene,tfNames)#
		clusterStack[[kk]]$regDBnotInClust <- clusterStack[[kk]]$regDB[which(!clusterStack[[kk]]$regDB %in% clusterStack[[kk]]$rows)]#
		##AM ## add priors into cluster stack, that way lapply can send each clust its' own priors#
		clusterStack[[kk]]$prior.names <- clusterStack[[kk]]$regDBnotInClust#
		#clusterStack[[kk]]$prior.pvals <- priorPvals[[kk]]#
		clusterStack[[kk]]$prior.pvals <- rep(1e-50,length(clusterStack[[kk]]$regDBnotInClust))#
		############ END DEBUG code ###############
	}#
	rm( kk )#
}
######### READ IN AND PREPARE DATA ##############
##########################################################################################
  ## Read gene-expression matrix#
  ##RB, ecoli ## source("R_scripts/readExpression.R")#
  cat("preparing to standardize data\n")#
  if (stdRatios) {#
    ## currently to 0-1 with slight inflation of range for logistic regression#
    ##ratios.tmp <- standardize.row.logistic( ratios , delta.xx = 0.05)#
    ratios.tmp <- standardize.row( ratios )#
    dimnames(ratios.tmp) <- dimnames(ratios)#
    ratios <- ratios.tmp#
    rm (ratios.tmp)#
    cat("standardized ratios\n")#
  } else {#
    cat("did not standardize ratios\n")#
  }#
#
  gc()
## read functions (i.e. are you a transcription factor or a kinase)#
  ## also get all regulatory influence squared away#
  ##tf.names <- getTfNames.new(file = "data/halo_NRC1transcription_factors_110804.txt", gene.ids)#
  tf.names <- tfNames[tfNames %in% rownames( ratios )]#
  rm( tfNames )#
  cat("getting list of guys that don't change significantly\n")#
  ##no.change <- lambdaFilt( lambdas, 15, mode = "names", n.thresh = 5)#
#
  ## we need to fix this !!!! RB ecoli 7/2007#
  ## aviv, you sent the already norm data, so I can't filter no change#
  no.change <- character() #
  cat("slicing tf names by changing vec\n")#
#
  tf.names.sig <- tf.names[! tf.names %in% no.change ]#
  tf.excluded <-  tf.names[ tf.names %in% no.change ]#
#
  ## precluster reg.infs#
  tf.tmp <- pre.cluster.regInfs(  tf.names.sig, ratios, cor.cut = 0.850 )#
#
  ## keep the original list of tfs that change in the prereq number of conds#
  tf.names.sig.raw <-  tf.names.sig#
  ## below we make a list of the guys that I've combined into other tfs#
  tf.removed.combined <-  tf.names.sig[! tf.names.sig %in% tf.tmp$tfs ]#
  ## now I override the surviving, more independent set of tfs (some rep more than one tf)#
  tf.names.sig <- tf.tmp$tfs#
  ## given a tf name in the new set of ind tfs who does each guy represent?#
  ## list with key being members of overwritten tf.names.sig#
  tf.combined.map <- tf.tmp$tf.cors#
  #
  ##reg.infs <- c(tf.names.sig, torsionHistone.names, env.sig)#
  env.sig <- relevant.env#
  if ( pred.subset.mode == "env" ) {#
    reg.infs <- env.sig#
  } else {#
    reg.infs <- unique( c(tf.names.sig, env.sig) )#
  }#
    #
  cat("loaded list of regulatory influences (tfs)\n")#
  cat("reg infs: \n")#
  print( reg.infs )
 tf.excluded
tf.names
 tf.names.sig
no.change
! tf.names %in% no.change
no.change <- lambdaFilt( lambdas, 15, mode = "names", n.thresh = 5)
load("../tags/working_run_for_halo_cell_paper/output/nwInf.out.tall_predall.RData")
lambdas
save(lambdas,file="data/lambdasHalo.RData")
if (organism == "ecoli")#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
else if{                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}
if (organism == "ecoli")#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
elseif{                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}
if (organism == "ecoli"){#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
else if{                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
#
## May 2008 Inferelator version 1.2#
## Bonneau lab - Aviv Madar#
#
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
rm(list=ls()) # start with a fresh workspace#
#
## main.R#
# keep a log file#
cat(file="output/log.txt","start at:",date(),"\n")#
inf.version <- "nwInf.1.2"#
date.nwInf.run <- date()#
#
#////////////////// USER PARAMS #//////////////////#
# trunc.cs <- F#
trunc.cs <- T#
# trunc.cs.i <- 900000000 ## 20#
trunc.cs.i <- 2#
organism == "halo" # organism == "ecoli"#
#
mod.bi.cols <- FALSE#
plot.it <- TRUE#
#
singleInfer <- "all" # singleInfer <- 350#
#
# set how many predictor max you want per transcriptional unit#
num.single.pred = 7; num.inter.pred = 5#
# set correlation by which interaction predictors are filtered (if bigger)#
max.inter.corr.cutoff = 0.75#
# set correlation by which single predictors are filtered (if bigger)#
max.single.corr.cutoff = 0.9#
# set the time scale (should be around the expected half life of mRNA in minutes)#
tau=15#
#
#////////////////// USER ADVANCED PARAMS #//////////////////#
##AM #a param to control what quantile of pval we give the priors#
lars.use.prob <- F  ##adding a boolean to determine whether or not to use lars with prior probs greeny#
alpha = 0#
time.mode = "all"#
relevant.env <- character()#
pred.subset.mode = "all"#
stdRatios <- TRUE#
force.reRead <- T#
add.loners <- F#
use.maxes <- FALSE ## Use maxes in addition to mins for interactions?#
#
##################  cmnd Line stuff , initializing ##################
#
if (organism == "ecoli"){#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
else if (organism == "halo") {                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}#
#
source("R_scripts/initialize.R")#
initialize()#
dir.create( "output" )#
#
if ( ! exists("restart.kk") ) restart.kk <- 1#
#
if (force.reRead) cat ("Forced to reread in data\n")#
#
if ( file.exists( "output/nwInf.startup.RData" ) && ! force.reRead ) {#
  cat( "Reading saved initialization data...\n" )#
  old.restart.kk <- restart.kk#
  load( "output/nwInf.startup.RData" )#
  restart.kk <- old.restart.kk#
  rm( old.restart.kk )#
  initialize()#
  #
} else { ### started with arguments#
    currentHost <- system("hostname") #
    ##biclustFile <- "data/k-clust_i6_k273.clean.RData"#
    for (zz in all.data.files) load( paste("data/",zz, sep = "") )#
    rm(zz)#
    gene.ids <- rownames( ratios )#
}#
#
if (plot.it == FALSE) {#
    graphics.off()#
}#
  #
##########################################################################################
## why not do the best clusters first?#
if (trunc.cs) {#
	clusterStack <- sort.cluster.stack( clusterStack , trunc.cs.i)#
	if ( trunc.cs.i > clusterStack$k ) {#
		trunc.cs.i <- clusterStack$k#
	}#
	clusterStack <- clusterStack[1:trunc.cs.i]#
	clusterStack$k <- trunc.cs.i#
	cat("TRUNCATING CLUSTERSTACK TO ",trunc.cs.i, " IS THIS WHAT YOU WANT TO DO????\n")#
}#
#
if ( is.null( clusterStack$k)  ) {#
	if ( length( clusterStack[[ length( clusterStack ) ]] ) == 1 ) {#
		names( clusterStack ) [ length( clusterStack ) ] <- "k"#
	} else {#
		stop( "check cluster stack ... no $k ... \n")#
	}#
}#
#
if (singleInfer > 0 && singleInfer <= clusterStack$k) {#
	cat("infferring for cluster: ", singleInfer, "\n")#
	singleInfer <- as.integer(singleInfer)#
} else {#
	cat("Fire it up! we're inferelating the whole bunch!!!\n singleInfer switch not set or greater than k \n")#
	singleInfer <- "all"#
}#
#
if (lars.use.prob == T){#
	##AM # source regDB interactions as a list of reg->genes#
	source("R_scripts/readRegDBInteractionsFromSif.R")		#
	source("R_scripts/getRegDBintoClusterStack.R")#
	for (kk in 1:clusterStack$k ) {#
		############ DEBUG code ################
		clusterStack[[kk]]$regDB <- getRegDBintoClusterStack(clusterStack[[kk]],regDB_tf_to_gene,tfNames)#
		clusterStack[[kk]]$regDBnotInClust <- clusterStack[[kk]]$regDB[which(!clusterStack[[kk]]$regDB %in% clusterStack[[kk]]$rows)]#
		##AM ## add priors into cluster stack, that way lapply can send each clust its' own priors#
		clusterStack[[kk]]$prior.names <- clusterStack[[kk]]$regDBnotInClust#
		#clusterStack[[kk]]$prior.pvals <- priorPvals[[kk]]#
		clusterStack[[kk]]$prior.pvals <- rep(1e-50,length(clusterStack[[kk]]$regDBnotInClust))#
		############ END DEBUG code ###############
	}#
	rm( kk )#
}#
#
#
#
######### READ IN AND PREPARE DATA ##############
##########################################################################################
  ## Read gene-expression matrix#
  ##RB, ecoli ## source("R_scripts/readExpression.R")#
  cat("preparing to standardize data\n")#
  if (stdRatios) {#
    ## currently to 0-1 with slight inflation of range for logistic regression#
    ##ratios.tmp <- standardize.row.logistic( ratios , delta.xx = 0.05)#
    ratios.tmp <- standardize.row( ratios )#
    dimnames(ratios.tmp) <- dimnames(ratios)#
    ratios <- ratios.tmp#
    rm (ratios.tmp)#
    cat("standardized ratios\n")#
  } else {#
    cat("did not standardize ratios\n")#
  }#
#
  gc()#
#
#############################################################################
  ## read functions (i.e. are you a transcription factor or a kinase)#
  ## also get all regulatory influence squared away#
  ##tf.names <- getTfNames.new(file = "data/halo_NRC1transcription_factors_110804.txt", gene.ids)#
  tf.names <- tfNames[tfNames %in% rownames( ratios )]#
  rm( tfNames )
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
#
## May 2008 Inferelator version 1.2#
## Bonneau lab - Aviv Madar#
#
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
rm(list=ls()) # start with a fresh workspace#
#
## main.R#
# keep a log file#
cat(file="output/log.txt","start at:",date(),"\n")#
inf.version <- "nwInf.1.2"#
date.nwInf.run <- date()#
#
#////////////////// USER PARAMS #//////////////////#
# trunc.cs <- F#
trunc.cs <- T#
# trunc.cs.i <- 900000000 ## 20#
trunc.cs.i <- 2#
organism == "halo" # organism == "ecoli"#
#
mod.bi.cols <- FALSE#
plot.it <- TRUE#
#
singleInfer <- "all" # singleInfer <- 350#
#
# set how many predictor max you want per transcriptional unit#
num.single.pred = 7; num.inter.pred = 5#
# set correlation by which interaction predictors are filtered (if bigger)#
max.inter.corr.cutoff = 0.75#
# set correlation by which single predictors are filtered (if bigger)#
max.single.corr.cutoff = 0.9#
# set the time scale (should be around the expected half life of mRNA in minutes)#
tau=15#
#
#////////////////// USER ADVANCED PARAMS #//////////////////#
##AM #a param to control what quantile of pval we give the priors#
lars.use.prob <- F  ##adding a boolean to determine whether or not to use lars with prior probs greeny#
alpha = 0#
time.mode = "all"#
relevant.env <- character()#
pred.subset.mode = "all"#
stdRatios <- TRUE#
force.reRead <- T#
add.loners <- F#
use.maxes <- FALSE ## Use maxes in addition to mins for interactions?
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
#
## May 2008 Inferelator version 1.2#
## Bonneau lab - Aviv Madar#
#
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.#
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \#
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '#
rm(list=ls()) # start with a fresh workspace#
#
## main.R#
# keep a log file#
cat(file="output/log.txt","start at:",date(),"\n")#
inf.version <- "nwInf.1.2"#
date.nwInf.run <- date()#
#
#////////////////// USER PARAMS #//////////////////#
# trunc.cs <- F#
trunc.cs <- T#
# trunc.cs.i <- 900000000 ## 20#
trunc.cs.i <- 2#
organism = "halo" # organism == "ecoli"#
#
mod.bi.cols <- FALSE#
plot.it <- TRUE#
#
singleInfer <- "all" # singleInfer <- 350#
#
# set how many predictor max you want per transcriptional unit#
num.single.pred = 7; num.inter.pred = 5#
# set correlation by which interaction predictors are filtered (if bigger)#
max.inter.corr.cutoff = 0.75#
# set correlation by which single predictors are filtered (if bigger)#
max.single.corr.cutoff = 0.9#
# set the time scale (should be around the expected half life of mRNA in minutes)#
tau=15#
#
#////////////////// USER ADVANCED PARAMS #//////////////////#
##AM #a param to control what quantile of pval we give the priors#
lars.use.prob <- F  ##adding a boolean to determine whether or not to use lars with prior probs greeny#
alpha = 0#
time.mode = "all"#
relevant.env <- character()#
pred.subset.mode = "all"#
stdRatios <- TRUE#
force.reRead <- T#
add.loners <- F#
use.maxes <- FALSE ## Use maxes in addition to mins for interactions?
#
if (organism == "ecoli"){#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
else if (organism == "halo") {                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}#
#
source("R_scripts/initialize.R")#
initialize()#
dir.create( "output" )#
#
if ( ! exists("restart.kk") ) restart.kk <- 1#
#
if (force.reRead) cat ("Forced to reread in data\n")#
#
if ( file.exists( "output/nwInf.startup.RData" ) && ! force.reRead ) {#
  cat( "Reading saved initialization data...\n" )#
  old.restart.kk <- restart.kk#
  load( "output/nwInf.startup.RData" )#
  restart.kk <- old.restart.kk#
  rm( old.restart.kk )#
  initialize()#
  #
} else { ### started with arguments#
    currentHost <- system("hostname") #
    ##biclustFile <- "data/k-clust_i6_k273.clean.RData"#
    for (zz in all.data.files) load( paste("data/",zz, sep = "") )#
    rm(zz)#
    gene.ids <- rownames( ratios )#
}#
#
if (plot.it == FALSE) {#
    graphics.off()#
}
organism
if (organism == "ecoli"){#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
else if (organism == "halo") {                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}
#
if (organism == "ecoli"){#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
elseif (organism == "halo") {                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}
#
if (organism == "ecoli"){#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
            	        }#
else if (organism == "halo") {                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}
#
if (organism == "ecoli"){#
	all.data.files <- c("clusterStackE.coli200611061514-clean.RData",   #
     	                "ratiosEcoli-445.RData",#
        	            "colMapEcoli-445.RData",                 #
            	        "tfNamesEcoli-445.RData") #
            	        }#
ifelse (organism == "halo") {                     #
	all.data.files <- c("clusterStackHalo.RData",   #
    	                "ratiosHalo-445.RData",#
        	            "colMapHalo-445.RData",                 #
            	        "tfNamesHalo.RData",#
                	    "lambdasHalo.RData") #
}

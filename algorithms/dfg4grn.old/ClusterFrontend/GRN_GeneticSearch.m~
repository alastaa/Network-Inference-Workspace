%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GRN_DistribSearch
% This file contains the frontend to perform the distributed search
% to find good hyperparameter's for Piotr's state space algorithm.
% Currently, this code only supports a basic grid search, but other
% algorithms such as Simulated Annealing are planned.
% This file also contains the necessary methods to evaluate the output
% models.
% 
% Params:
%   out_dir - this is what to call the test.  The results will be
%              saved in a folder with this name.
%   num_models - this is the number of models to run per hyperparamter
%                selection.  This should be between 20 and 100.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
function GRN_GeneticSearch(out_dir, script_name, num_gens, num_models, ...
  pop_s, meas_name, gamma_range, lambda_w_range, tau_range)

 
% Parameters
% ----------

% Number of times to run each hyperparameter combination
% so we can average across them.
%if (nargin < 4)
if(~exist('out_dir'))
    out_dir = 'test';
end
if(~exist('script_name'))
    script_name = 'Script_Debug_Tanh';
end
if(~exist('num_gens'))
    num_gens = 20;
end
if(~exist('num_models'))
    num_models = 20;
end
if(~exist('meas_name'))
    meas_name = 'error_trend_r2';
end

global pop_size;
if(exist('pop_s'))
    pop_size = pop_s;
else
    pop_size = 60;
end



if(~exist('gamma_range'))
    gamma_range = [0.1 1];
end
if(~exist('lambda_w_range'))
    lambda_w_range = [0.1 1];
end
if(~exist('tau_range'))
    tau_range = [3 5];
end

date_string = datestr(clock, 'yyyy-mm-dd_HH-MM-ss');

% Create a data structure for storing generational data
global generations;
generations = cell(1,num_gens);
for i = 1:num_gens
    generations{i} = struct('parents', cell(1,pop_size), ...
        'children', cell(1,pop_size), 'elites', cell(1,pop_size));
end

% Initialize our first generation.
initialize_gen(pop_size, gamma_range, lambda_w_range, tau_range);  
    

global results;
results = zeros(1,num_gens);

% Hyperparameter selection
% ------------------------
 
% Launch genetic search
fprintf(1, 'GRN: optimizing %s %s %s via genetic algorithm...\n', 'tau',...
    'gamma', 'lambda_w');
out_dir = strcat(out_dir, '_', date_string, '_genetic');
[best_meas, best_child] = ...
  Selection(pop_size, script_name, out_dir, num_gens, ...
  num_models, meas_name, gamma_range, lambda_w_range, tau_range);
    
fprintf(1, 'GRN: best %s=%g for %s=%g, %s=%g, %s=%g\n', ...
  meas_name, best_meas, 'tau', best_child.params.tau, ...
  'lambda_w', best_child.params.lambda_w, 'gamma', ...
  best_child.params.gamma);

exit
end


% -------------------------------------------------------------------------
% Code to evaluate the models generated by grid search.  Assume that they
% were saved in a directory in the out_dir dir with the same name as out_dir
% and are numbered sequentially.
% Given a file that contains N number of models, go through them extracting
% the best epoch.  Then average that epoch with the best epoch from the
% other models.
% -------------------------------------------------------------------------
function [best_meas, best_child] = ...
  EvalModels(out_dir, meas_name, current_generation)

global generations;
global pop_size;

% Get the list of Matlab files
files = dir([out_dir '/*.mat']);

% Inspect all results
if(current_generation == 1)
    best_meas = -inf;
    best_gamma = -inf;
    best_lambda_w = -inf;
    best_tau = -inf;
else
    best_meas = generations{current_generation}(1).children.fitness;
    best_gamma = generations{current_generation}(1).children.params.gamma;
    best_lambda_w = generations{current_generation}(1).children.params.lambda_w;
    best_tau = generations{current_generation}(1).children.params.tau;
end


for i = 1:length(files)
  % Get the MODEL and METER_INFER_TEST variables from file <i>
  d = load(sprintf('%s/%s', out_dir, files(i).name));

  % Evaluate measure
  meas = eval(['d.METER_INFER_TEST{end}.last_' meas_name ';']);
  
  % Fill in the measure
%   for j = 1:pop_size
%       j
%       current_generation
%       generations{current_generation}
%       generations{current_generation}(j)
%      if generations{current_generation}(j).children.params.tau ...
%              == d.params.tau && ...
%         generations{current_generation}(j).children.params.gamma ...
%              == d.params.gamma && ...
%         generations{current_generation}(j).children.params.lambda_w ...
%              == d.params.lambda_w
%          
%         generations{current_generation}(j).children.fitness = meas;
%      end  
%   end

    generations{current_generation}(i+2).children.params.tau ...
          = d.params.tau
    generations{current_generation}(i+2).children.params.gamma ...
          = d.params.gamma
    generations{current_generation}(i+2).children.params.lambda_w ...
          = d.params.lambda_w

    generations{current_generation}(i+2).children.fitness = meas;

  if (meas > best_meas)
    best_meas = meas;

    best_lambda_w = d.params.lambda_w;

    best_tau = d.params.tau;

    best_gamma = d.params.gamma;
    
  end
end

best_child = new_child();
best_child.params.lambda_w = best_lambda_w;
best_child.params.tau = best_tau;
best_child.params.gamma = best_gamma;


o = zeros(pop_size,1);
for i = 1:pop_size
    o(i) = generations{current_generation}(i).children.fitness;
end
o

sprintf('Sorting...\n');

[unused, order] = sort(o, 'descend');

generations{current_generation} = ...
    generations{current_generation}(order); 
 
end

% -------------------------------------------------------------------------
% Generate children based on Deb/Beyer (2001)'s SBX algorithm.
% Crossover for real numbers.
% -------------------------------------------------------------------------
function [child1, child2] = Crossover(parent1, parent2, ...
    gamma_range, lambda_w_range, tau_range, n)
    if n > 5        % As n shrinks, the search space narrows in
        n = 4;
    else
        n = n / 2;
    end                 
    u = rand;
    if u <= 0.5
        b_q = (2*u)^(1/(n+1));
    else
        b_q = (1/(2*(1-u)))^(1/(n+1));
    end
    
    child1 = new_child;
    child2 = new_child;
    
    child1.params.lambda_w = 0.5*((1+b_q) * parent1.params.lambda_w + ...
        (1-b_q) * parent2.params.lambda_w);
    child2.params.lambda_w = 0.5*((1-b_q)*parent1.params.lambda_w + ...
        (1+b_q)*parent2.params.lambda_w);
    
    child1.params.tau = 0.5*((1+b_q)*parent1.params.tau + ...
        (1-b_q)*parent2.params.tau);
    child2.params.tau = 0.5*((1-b_q)*parent1.params.tau + ...
        (1+b_q)*parent2.params.tau);
    
    child1.params.gamma = 0.5*((1+b_q)*parent1.params.gamma + ...
        (1-b_q)*parent2.params.gamma);
    child2.params.lambda_w = 0.5*((1-b_q)*parent1.params.gamma + ...
        (1+b_q)*parent2.params.gamma);
    
    if child1.params.tau == parent1.params.tau &&

    
    if child1.params.tau < tau_range(1)
        child1.params.tau = tau_range(1);
    end
    if child1.params.tau > tau_range(2)
        child1.params.tau = tau_range(2);
    end
    if child1.params.lambda_w < lambda_w_range(1)
        child1.params.lambda_w = lambda_w_range(1);
    end
    if child1.params.lambda_w > lambda_w_range(2)
        child1.params.lambda_w = lambda_w_range(2);
    end
    if child1.params.gamma < gamma_range(1)
        child1.params.gamma = gamma_range(1);
    end
    if child1.params.gamma > gamma_range(2)
        child1.params.gamma = gamma_range(2);
    end
    
    if child2.params.tau < tau_range(1)
        child2.params.tau = tau_range(1);
    end
    if child2.params.tau > tau_range(2)
        child2.params.tau = tau_range(2);
    end
    if child2.params.lambda_w < lambda_w_range(1)
        child2.params.lambda_w = lambda_w_range(1);
    end
    if child2.params.lambda_w > lambda_w_range(2)
        child2.params.lambda_w = lambda_w_range(2);
    end
    if child2.params.gamma < gamma_range(1)
        child2.params.gamma = gamma_range(1);
    end
    if child2.params.gamma > gamma_range(2)
        child2.params.gamma = gamma_range(2);
    end
end

% -------------------------------------------------------------------------
% Generate children based on mutation
% -------------------------------------------------------------------------
function [child1] = Mutate(parent1)
    
end

% -------------------------------------------------------------------------
% Function to create a new generation in the main struct
% -------------------------------------------------------------------------
function new_gen(gen_num, parents, children, elite)
    global generations;
    generations(gen_num) = struct('parents', parents, 'children', ...
        children, 'elite', elite);
end

% -------------------------------------------------------------------------
% Function to create a new struct for a child
% -------------------------------------------------------------------------
function [child] = new_child
    child = struct('params', [], 'fitness', -inf);
    child.params = struct('lambda_w', 0, 'tau', 0, 'gamma', 0);
end

% -------------------------------------------------------------------------
% Initialize the first generation to somewhat random values within ranges
% -------------------------------------------------------------------------
function initialize_gen(pop_size, gamma_range, lambda_w_range, tau_range)
    global generations;
    fprintf('Initializing...\n');
    
    for i = 1:pop_size
        child = new_child();
        child.params.lambda_w = lambda_w_range(1) + ...
            ((rand * lambda_w_range(2)) - lambda_w_range(1));
        child.params.tau = tau_range(1) + ...
            ((rand * tau_range(2)) - tau_range(1));
        child.params.gamma = gamma_range(1) + ...
            ((rand * gamma(2)) - gamma_range(1));
        generations{1}(i).children = child;
                
    end
end

% -------------------------------------------------------------------------
% Send the child to SGE for evaluation
% -------------------------------------------------------------------------
function Submit_To_Cluster(script_name, num_models, ...
    dirname, child, jobs_count)

    shell_script = 'grn_submit.sh';
    path_to_scripts = which('GRN_GeneticSearch');
    idx = strfind(path_to_scripts,'/');
    path_to_scripts = path_to_scripts(1:idx(length(idx))-1);
    
    fprintf(1, 'GRN: Testing %s=%g, %s=%g, %s=%g, %g times...\n', ...
    'gamma', child.params.gamma, 'tau', child.params.tau, 'lambda_w', ...
    child.params.lambda_w, num_models);

    out_file = sprintf('%s/%s-%g_%s-%g_%s-%g-%g.mat', ...
        dirname, 'gamma', child.params.gamma, 'tau', ...
        child.params.tau, 'lambda_w',child.params.lambda_w, jobs_count);
    
    command = sprintf('%s/%s %s %s %s %d %s %g %s %g %s %g', ...
        path_to_scripts, shell_script, path_to_scripts, ...
        script_name, out_file, num_models, ...
        'gamma', child.params.gamma, 'tau', ...
        child.params.tau, 'lambda_w', child.params.lambda_w);
    system(command);
end

% -------------------------------------------------------------------------
% GA Code.  This code will select parents for cross, test the children
% ------------------------------------------------------------------------
function [best_meas, best_child] = ...
  Selection(pop_size, script_name, out_dir, num_gen, ...
  num_models, meas_name, gamma_range, lambda_w_range, tau_range)

    global generations;
    global results;
    mkdir(out_dir);

% We start in the second generation because the first one was initialized
% already, but only has children.  So we want to breed those children and
% then start testing.
    for current_gen_num = 2:num_gen
        
         for i = 1:pop_size
             generations{current_gen_num}(i).parents = ...
                 generations{current_gen_num-1}(i).children;
         end
        
        
        dirname = [pwd '/' out_dir '/Gen-' int2str(current_gen_num)];
        mkdir(dirname);
        
        n = num_gen - (current_gen_num - 1);
        pop_cap = pop_size / (current_gen_num / 2);
        
        % Carry over best two parents from previous round
        
       generations{current_gen_num}(1).children = generations{current_gen_num}(1).parents;
       elite_1 = generations{current_gen_num}(1).children;
       generations{current_gen_num}(2).children = generations{current_gen_num}(2).parents;
       elite_2 = generations{current_gen_num}(2).children;
       % Now make sure that the elites from the last round breed at least
       % once this round:
       parent_1 = generations{current_gen_num}(1 + round(rand * (pop_cap - 1))).parents;
       parent_2 = generations{current_gen_num}(1 + round(rand * (pop_cap - 1))).parents;
       
       % Possibly base this on fitness instead
        child_pointer = 3;  % Pointer to where to put the next child
                            % It is 3 because we are keeping the first two
                            % parents untouched (they are the elites).
        jobs_count = 0;
        
        
        
        
        %----- First elite
        
        [new_child_1 new_child_2] = Crossover(parent_1, elite_1, ...
               gamma_range, lambda_w_range, tau_range, n);
        
        generations{current_gen_num}(child_pointer).children = new_child_1;
        generations{current_gen_num}(child_pointer + 1).children = new_child_2;
        
        fprintf('Children from elites\n')
           new_child_1.params
           new_child_2.params
        
        child_pointer = child_pointer + 2;
        
        Submit_To_Cluster(script_name, num_models, dirname, ...
               new_child_1, jobs_count);
           jobs_count = jobs_count + 1;
        Submit_To_Cluster(script_name, num_models, dirname, ...
               new_child_2, jobs_count);
           jobs_count = jobs_count + 1;
           
        %----- Second elite
           
        [new_child_1 new_child_2] = Crossover(parent_2, elite_2, ...
               gamma_range, lambda_w_range, tau_range, n);
        
        generations{current_gen_num}(child_pointer).children = new_child_1;
        generations{current_gen_num}(child_pointer + 1).children = new_child_2;
        
        fprintf('Children from elites\n')
           new_child_1.params
           new_child_2.params
        
        child_pointer = child_pointer + 2;
        
        Submit_To_Cluster(script_name, num_models, dirname, ...
               new_child_1, jobs_count);
           jobs_count = jobs_count + 1;
        Submit_To_Cluster(script_name, num_models, dirname, ...
               new_child_2, jobs_count);
           jobs_count = jobs_count + 1;
           
        % Now select the rest of the population, up until pop_size
        
        while child_pointer <= pop_size
           % Select two random parents for combination
           parent_1 = generations{current_gen_num}(1 + round(rand * (pop_cap - 1))).parents;
           parent_2 = generations{current_gen_num}(1 + round(rand * (pop_cap - 1))).parents;
                      
           [new_child_1 new_child_2] = Crossover(parent_1, parent_2, ...
               gamma_range, lambda_w_range, tau_range, n);

           generations{current_gen_num}(child_pointer).children = new_child_1;
           generations{current_gen_num}(child_pointer + 1).children = new_child_2;

           new_child_1.params
           new_child_2.params
           
           child_pointer = child_pointer + 2;

           Submit_To_Cluster(script_name, num_models, dirname, ...
               new_child_1, jobs_count);
           jobs_count = jobs_count + 1;
           Submit_To_Cluster(script_name, num_models, dirname, ...
               new_child_2, jobs_count);
           jobs_count = jobs_count + 1;
        end
        
        % Wait for the jobs to complete
        fprintf(1, 'Waiting for worker functions to return...\n');
        jobs_completed = (length(dir([dirname '/*.mat'])));
        if(exist('best_meas') && exist('best_child'))
           fprintf(1,'-------\n%g is the best %s found so far, gamma=%g, lambda_w=%g, tau=%g\n-------\n',...
               best_meas, meas_name, best_child.params.gamma, best_child.params.lambda_w,...
               best_child.params.tau);
        end
        results
        while (jobs_completed < jobs_count)
          % When counting the jobs, include the .txt file
          jobs_completed = (length(dir([dirname '/*.mat'])));
          fprintf(1,'%3g out of %3g have returned in %s...\n', ...
            jobs_completed, jobs_count, dirname);
          pause(5)
        end
        fprintf(1,'SUCCESS: all %g jobs have returned...\n', jobs_completed);

        % Evaluate the jobs
        sprintf('Evalmodels\n');
        [best_meas, best_child] = EvalModels(dirname, meas_name, ...
            current_gen_num);
        sprintf('Out of Evalmodels\n');

        fprintf(1, 'Best %s=%g at %s=%g, %s=%g, %s=%g\n\n', meas_name, best_meas, ...
            'tau', best_child.params.tau, ...
            'lambda_w', best_child.params.lambda_w, ...
            'gamma', best_child.params.gamma );
        
        
        results(current_gen_num) = best_meas;
        save([out_dir '/' out_dir '-Results.mat'], 'best_child', 'results');
        
        % Remove last generations directory to save space
        if current_gen_num > 3
            [pwd '/' out_dir '/Gen-' int2str(current_gen_num - 2)]
            %rmdir([pwd '/' out_dir '/Gen-' int2str(current_gen_num - 2)], 's');
        end
        
        results
    end
end

function child_num = Get_Child(current_gen_num)
    global pop_size;
    while(1)
       for i = 1:pop_size
           
       end
    end
end


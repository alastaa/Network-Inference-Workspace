##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '
## May 2010 Dream3/4 pipeline (MCZ,tlCLR,Inferelator)
## Bonneau lab - "Aviv Madar" <am2654@nyu.edu>, 
##  		     "Alex Greenfield" <ag1868@nyu.edu> 
## NYU - Center for Genomics and Systems Biology
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '

#This file contains the scripts that make the necessary R objects

#function makeRatios
#DESCRIPTION:
#		makes the matrix of experimental data used by our inference pipeline.
#   ratios will have as many rows as there are genes, and as many columns as there are expi
#		ratios is a term kept from cDNA (two color) microarrays 
# 	which provided only ratios (compared to ctrl) for each mRNA's expression levels
#INPUT: 
#1) chalName - the name of the challenge. Is one of: "DREAM2", "DREAM3", "DREAM4"
#2) dirPath -  the path to the directory that contains all of the data
#			e.g. dirPath <- "exampleRawData/DREAM4_in-silico_challenge/Size_100/insilico_size100_1/"
#			note that dirPath points to the directory that is assumed to contain the following four files:
#			1) timeseries.tsv  - data containing the time-series response of the system to perturbations			
#			2) knockouts.tsv   - data containing the steady-state response of the system to knockouts
#			3) knockdowns.tsv  - data containing the steady-state esponse of the system to knockdowns
#			4) wildtype.tsv		 - data containing the wild-type expression of each gene 
#													 (i.e. the expression under no perrurbations)
#OUTPUT
#1) ratios - the matrix of expression measurements used by the inference pipeline
#						 each row corresponds to a particular gene, and each column to a condition
makeRatios <- function(chalName, dirPath){

	#we first load each of the four different datasets
	dream_ts <- t(read.table(file=paste( dirPath,"timeseries.tsv", sep=""),sep="\t",header=T))
	colnames(dream_ts) <- dream_ts[1,]
	dream_ts <- dream_ts[-1,]
	dream_ko <- t(read.table(file=paste(dirPath,"knockouts.tsv", sep=""),sep="\t",header=T))
	dream_kd <- t(read.table(file=paste(dirPath,"knockdowns.tsv", sep=""),sep="\t",header=T))
	dream_wt <- as.matrix(read.table(file=paste(dirPath,"wildtype.tsv", sep=""),sep="\t",header=T))
	
	#we add columnames to the knockout and knocdown data, respectively 
	colnames(dream_ko) <- paste(rownames( dream_ts ),"(-/-)",sep="")
	colnames(dream_kd) <- paste(rownames( dream_ts ),"(+/-)",sep="")
	
	#we now format the time-series data
	#Note that this formatting is slightly different for each dataset
	#For DREAM4 the simulated time-series data was generated by first
	#applying a perturbation for a length time (500 arbitrary units)
	#and then removing the perturbation for 500 arbitrary units. Thus
	#for the DREAM4 time-series data we treat each time-series as
	#two distinct time-series of 11 measurements each
	#For DREAM2 and DREAM3 the simulated time-series data was generated
	#by applying a perturbation and measuring over time. For DREAM2 each
	#time-series had 26 time-points, and for DREAM3 each time-series
	#had 21 time-points
	
	splitTs <- FALSE #this boolean is set to TRUE only for DREAM4
	numMesPerTs <- c()
	if( chalName == "DREAM4" ){
		splitTs <- TRUE
		numMesPerTs <- 11 
	}else if(chalName == "DREAM3"){
		numMesPerTs <- 21
	}else{
		numMesPerTs <- 26
	}
	
	#here we create the columnames for the time-series data
	#if splitTs is TRUE then the end of one time-series is the start of the
	#next time series. To account for this we create a new matrix for the time-series data
	if( !splitTs ){
		curTs <- 1
		curInd <- 1
		curNumSamples <- 1
		curColNames <- colnames( dream_ts )
		newColNames <- c()
		for( i in 1:length( curColNames ) ){
			newColNames <- c( newColNames, paste("TS_",curTs,"delt_",curColNames[curInd],sep=""))
			curInd <- curInd + 1
			curNumSamples <- curNumSamples + 1
			if( curNumSamples > numMesPerTs ){
				curTs <- curTs + 1
				curNumSamples <- 1
			}
		}
		colnames(dream_ts) <- newColNames
	}else{
		curTs <- 1
		curInd <- 1
		curNumSamples <- 1
		curColNames <- colnames( dream_ts )
		newColNames <- c()
		newdream_ts <- c()
		for( i in 1:length( curColNames ) ){
			newColNames <- c( newColNames, paste("TS_",curTs,"delt_",curColNames[i],sep=""))
			newdream_ts <- cbind( newdream_ts, dream_ts[,i] )
			curNumSamples <- curNumSamples + 1
			curInd <- curInd + 1
			if( (curNumSamples > numMesPerTs) && ((curTs%%2) != 0) ){ #now we make the last measurement in the previous time series
				#the first measurement in this time series
				curTs <- curTs + 1
				newColNames <- c( newColNames, paste("TS_",curTs,"delt_",curColNames[i],sep=""))
				newdream_ts <- cbind( newdream_ts, dream_ts[,i] )
				curNumSamples <- 1
				curNumSamples <- curNumSamples + 1
			}else if( curNumSamples > numMesPerTs){
				curTs <- curTs + 1
				curNumSamples <- 1
			}
		}
		colnames( newdream_ts ) <- newColNames
		dream_ts <- newdream_ts		
	}
	
	ratios <- cbind( t(dream_wt), dream_ko, dream_kd, dream_ts )
	cNames <- colnames(ratios) 
	cNames[1] <- "wt"
	colnames(ratios) <- cNames

	return(ratios)
}


#function makeColMap
#DESCRIPTION: 
# 	makes a list where each element contains annotation for the corresponding
#   a expirement (column) in ratios (i.e. makeColMap[[1]] contains annotation for column       
# 	of ratios, makeColMap[[2]] contain annotation for column 2, etc). The annotation describes 
#		which columns are time-series and which are steady-state. This
#		information is used when building the design and response matrices
#INPUT:
#	  ratios 		- the expression data matrix created by makeRatios
#		numEq_exp - the number of steady-state experiments
#		del.t			- the time-interval between time-series measurements, which is assumed to be 
#								the same for all time-series (this assumption is true for the DREAM challenges)
#		chalName 	- the name of the challenge. Is one of: "DREAM2", "DREAM3", "DREAM4"
#OUTPUT:
#		colMap 		- list containing the annotations for each column
makeColMap <- function(ratios, numEq_exp, del.t, chalName) {
	colMap <- list()
	
	#each element of colMap stores "object" which is defined below
	#"object" by default describes an equilibrium (steady-state) measurement
	object <- list()
	object$isTs <- FALSE 
	object$is1stLast <- factor("e",levels=c("e","f","m","l"))
	object$prevCol <- as.logical("NA")
	object$del.t <- as.logical("NA")
	object$condName <- character()
	
	# counter that holds the number of time series experiments we have
	numTS = 0
	tsCount = 0
	cnames = colnames(ratios)
	# inhabit each element of colMap with "object"
	for (i in 1:dim(ratios)[2]){
		colMap[[ cnames[i] ]] <- object
		# here we assume that the coumns of ratios have the following order:
		# all steady-state expirements before all time-series expirements
		if(i > numEq_exp) { #now we have reached the time-series data
			numTS = numTS+1
			colMap[[i]]$isTs = TRUE
			
			#for a time series expirement we can have one of three cases
			#1) we are at the first conditions of a time-series
			#2) we are in the middle of a time-series
			#3) we are at the end of a time-series
			
			#in order to figure out where in the time-series we are we need
			#to know the current time-point and previous time-point
			curCNameNum <- as.numeric(strsplit(cnames[i],"_")[[1]][3])
			prevCNameNum <- as.numeric(strsplit(cnames[i-1],"_")[[1]][3])
			
			#we treat DREAM4 time-series differently than DREAM2 and DREAM3 time-series
			if(chalName == "DREAM4"){
				# /case1 first condition of a time-series experiment
				if( (curCNameNum == 0) || ((curCNameNum == 500) && (prevCNameNum == 500)) ) {
					tsCount = tsCount+1
					colMap[[i]]$is1stLast = factor("f",levels=c("e","f","m","l")) 
					colMap[[i]]$prevCol <- as.logical("NA")
					colMap[[i]]$del.t <- as.logical("NA")
				}
				# /case2 last condition of a time-series experiment 
				else if (  (curCNameNum == 1000) || ((curCNameNum == 500) && (prevCNameNum == 450)) ) { 
					colMap[[i]]$is1stLast = factor("l",levels=c("e","f","m","l"))
					colMap[[i]]$prevCol <- cnames[i-1]
					colMap[[i]]$del.t <- del.t
				} 
				# /case3 middle condition of a time-series experiment
				else {
					colMap[[i]]$is1stLast = factor("m",levels=c("e","f","m","l"))
					colMap[[i]]$prevCol <- cnames[i-1]
					colMap[[i]]$del.t <- del.t	
				}
			}
			else if(chalName == "DREAM3"){
				# /case1 first condition of a time-series experiment
				if( (curCNameNum == 0)) {
					tsCount = tsCount+1
					colMap[[i]]$is1stLast = factor("f",levels=c("e","f","m","l")) 
					colMap[[i]]$prevCol <- as.logical("NA")
					colMap[[i]]$del.t <- as.logical("NA")
				}
				# /case2 last condition of a time-series experiment
				else if (  curCNameNum == 200 ) { 
					colMap[[i]]$is1stLast = factor("l",levels=c("e","f","m","l"))
					colMap[[i]]$prevCol <- cnames[i-1]
					colMap[[i]]$del.t <- del.t
				} 
				# /case3 middle condition of a time-series experiment
				else {
					colMap[[i]]$is1stLast = factor("m",levels=c("e","f","m","l"))
					colMap[[i]]$prevCol <- cnames[i-1]
					colMap[[i]]$del.t <- del.t	
				}
			}else if(chalName == "DREAM2"){
				# /case1 first condition of a time-series experiment
				if( (curCNameNum == 0)) {
					tsCount = tsCount+1
					colMap[[i]]$is1stLast = factor("f",levels=c("e","f","m","l")) 
					colMap[[i]]$prevCol <- as.logical("NA")
					colMap[[i]]$del.t <- as.logical("NA")
				}
				# /case2 last condition of a time-series experiment
				else if (  curCNameNum == 500 ) { 
					colMap[[i]]$is1stLast = factor("l",levels=c("e","f","m","l"))
					colMap[[i]]$prevCol <- cnames[i-1]
					colMap[[i]]$del.t <- del.t
				} 
				# /case3 middle condition of a time-series experiment
				else {
					colMap[[i]]$is1stLast = factor("m",levels=c("e","f","m","l"))
					colMap[[i]]$prevCol <- cnames[i-1]
					colMap[[i]]$del.t <- del.t	
				}
		}
	 }
		colMap[[i]]$condName <- cnames[i]
	}	
	colMap[["numTS"]] = numTS #stores number of time-series expirements we have
	
	return(colMap)
}

#function makeClusterStack
#DESCRIPTION:
#		makeClusterStack - makes a list where each elements contains annotation for	
#		the corresponding gene (i.e. clusterStack[[1]] corresponds to gene 1, clusterStack[[2]]
#		corresponds to gene 2, etc.). The annotation describes which columns (i.e. expirements)
#		have measurements for that particular gene. In the case of the DREAM challenges each
#		gene will be measured accross all conditions. Thus, clusterStack is retained solely
#		for backward compatibility with previous versions. For example,		
# 	in a prevous versions, a user could select to run the Inferelator on data from halobacterium salinarum.  
#		A bi-clustering algorithm was applied to the original data, and Inferelator was presented with gene modules(as oppossed to single genes) 
#		In this case expression data is avaliable for a gene module only across a subset of the overall conditions. Thus
#		the mapping of which conditions contain measurements for which gene modules becomes crucial

#INPUT:
#	  ratios 		   - the expression data matrix created by makeRatios
#OUTPUT:
#		clusterStack - a list containing the annotations for each row
makeClusterStack <- function(ratios){
	# create clusterStack (each cluster is a gene)
	object = list()
	object$cols = colnames(ratios)
	object$ncols = length(colnames(ratios))
	object$rows = character()
	object$nrows = 1
	object$resid = as.logical("NA")
	object$k = integer()
	object$redExp = numeric()
	
	clusterStack = list()
	for (i in 1:dim(ratios)[1]){
		clusterStack[[i]] = object
		clusterStack[[i]]$rows = rownames(ratios)[i]
		clusterStack[[i]]$k = i
		clusterStack[[i]]$redExp = ratios[i,] 
	}
	clusterStack[[(i+1)]] = i
	return(clusterStack)
}
